\chapter{GENERATING TARGET CODE}

This chapter discusses the mechanisms necessary to translate a decorated \emph{Scandal} AST into \emph{Java} bytecode. This target language is characterized by running on the \emph{Java Virtual Machine}, a multi-platform interpreter and just-in-time compiler. Bytecode is written as text, but ultimately converted into a binary representation in order to facilitate execution by the JVM. In order to compile a \emph{Scandal} AST into bytecode text and binary representations, the \emph{Scandal} compiler makes use of a \emph{Java} library called \il{org.objectweb.asm}, or ASM for short. This library provides many facilities, including an IDE plug-in that takes a \emph{Java} class and displays its corresponding bytecode implementation, as well as the necessary ASM calls to generate that bytecode. In fact, this method represents most of the work flow in implementing \emph{Scandal}. The entire work flow is roughly:

\begin{enumerate}
	\item Make choices for the language's concrete syntax.
	\item Introduce new symbols to the \il{Token} and \il{Scanner} classes, as needed, and test.
	\item Write a corresponding AST class, parsing routine, and test.
	\item Describe type-checking rules, implement \il{decorate} inside the AST class, and test.
	\item Write \emph{Java} code with the same functionality, and copy its ASM plug-in output.
	\item Paste the ASM plug-in output inside the AST class' \il{generate} method, substituting names, constants, and method signatures by properties belonging to the AST class, make adjustments, and test.
\end{enumerate}

Often adjustments and optimizations are necessary, as the ASM plug-in output contains many unnecessary calls to its API. These are usually routines that add comments and line numbering to the bytecode class, but that can cause significant bloat in the compiler. Although not necessary, minor optimizations and code re-orderings are usually made, such as duplicating the top of the stack instead of making another method call, for example. Also, for every \emph{Scandal} type that is overloaded, a check is inserted with the necessary type conversion, as types are not overloaded in the JVM in general.

The \emph{Java Virtual Machine} is stack-based, that is, operands are stored in a stack data structure. Operations consist mainly of pushing operands onto the stack, then calling a method. If the method is void, it will pop from the stack the operands it takes as arguments and leave the stack in the same state it was before those operands were pushed. If the method returns something then it will leave, in addition, a result on top of the stack, that is, after popping its required arguments. Stacks in the JMV are further bundled into entire frames, which contain data and local variables the stack can access. Bytecode is oblivious to most details pertaining to the implementation of frames, except for providing the frame's local variable count and maximum stack height. Naturally, these \emph{details} are fundamental for memory allocation in the JVM. Fortunately, computing these values is delegated entirely to the ASM library, as previously discussed.

\section{Generating a Program}

Generating bytecode in the \il{Program} class is a lot more complex than the corresponding decoration phase, since the overall structure for the entire underlying \emph{Java} class needs to be provided. This global task is accomplished inside the \il{generate} method by creating an instance of \il{org.objectweb.asm.ClassWriter}. The latter, which is stored locally in a property called \il{cw}, manages the creation of the \emph{Java} class itself, including the generation of the byte array used to instantiate and run the \emph{Scandal} program. In particular, the JRE is set to version 1.8, access to the class is made \il{public}, and the class is defined as a subclass of \il{java.lang.Object} that implements the \il{java.lang.Runnable} interface. This is all accomplished by calls to the ASM API, which manages writing a bytecode class with the appropriate instructions. Next, three instances of \il{org.objectweb.asm.MethodVisitor} are acquired by calling \il{cw.visitMethod}, one for each method in the \emph{Java} class. The methods are namely \il{init}, \il{run}, and \il{main}.

The \il{init} method basically goes through the node array and, if the particular node is an instance of \il{LambdaLitDeclaration}, a call is made to \il{node.generate}, passing the appropriate instance of \il{MethodVisitor} and the compiler's symbol table as arguments. What the \il{generate} method does inside a \il{LambdaLitDeclaration} is somewhat complicated, and its explanation deferred to the moment the \il{LambdaLitExpression} class is discussed. Before visiting \il{run}, \il{generate} goes once again over all nodes in the node array and, if they are either an instance of \il{LambdaLitDeclaration} or an instance of \il{FieldDeclaration}, it calls \il{cw.visitField}. The latter method creates fields in the \emhp{Java} class, which correspond to global variables in the \emph{Scandal} program. Every field is marked as \il{static}, since no use is made in \emph{Scandal} of \emph{Java}'s object-oriented paradigm.

In addition, lambda fields are marked as \il{final}, as previously discussed, and \il{cw} is passed along to the instances of \il{LambdaLitExpression} for which field declarations are being created, asking them to create method bodies for their respective lambda literal expressions. This is accomplished inside each lambda literal expression by an overloaded \il{generate} method, which takes, instead of a \il{MethodWriter}, an instance of \il{ClassWriter}, namely \il{cw}. Each lambda literal expression uses \il{cw} to create its own \il{MethodWriter}, which will write the lambda's corresponding method to the \emph{Java} class. These instances of \il{LambdaLitExpression} are accessed through the corresponding \il{lambda} property inside a \il{LambdaLitDeclaration} class, and the particularities of creating method bodies for lambdas will be discussed momentarily.

The next step is to add a body for the \emph{Java} class' \il{run} method. To do so, \il{generate} goes yet once more over the array of nodes, and this time it generates any node that is \emph{not} an instance of \il{LambdaLitDeclaration}, for obvious reasons. It does, however, visit instances of \il{FieldDeclaration}, since \il{cw.visitField} only created the fields, but never assigned any values to them. Since unassigned declarations are only allowed in \emph{Scandal} when declaring lambda parameters, there is always some value to assign to those fields at initialization, and \il{generate} inside \il{FieldDeclaration} takes care of exactly that. Finally, \il{generate} visits the \il{main} method in the \emph{Java} class, which is shown in Listing \ref{alg:main}.

\begin{lstlisting}[language=Java,caption={Using the ASM framework to construct a \il{main} method.},label={alg:main}]
private void addMain(ClassWriter cw, SymbolTable symtab) {
	MethodVisitor mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, "main",
		"([Ljava/lang/String;)V", null, null);
	mv.visitTypeInsn(NEW, symtab.className);
	mv.visitInsn(DUP);
	mv.visitMethodInsn(INVOKESPECIAL, symtab.className,"<init>","()V",false);
	mv.visitMethodInsn(INVOKEVIRTUAL, symtab.className, "run", "()V", false);
	mv.visitInsn(RETURN);
	mv.visitMaxs(0, 0);
}
\end{lstlisting}

\begin{enumerate}
	\addtocounter{enumi}{1}
	\item This is the standard \il{main} method in \emph{Java}, which is always \il{public} and \il{static}, takes an array of strings, and returns nothing. The bytecode syntax for arrays is that of a left bracket, followed by the type. Line 2 uses \il{cw} to create an instance of \il{MethodVisitor}, namely \il{mv}, with exactly these properties. Bytecode syntax for method signatures is given by a parenthesized list of argument types, followed by a return type. Hence a \il{void} method that takes a \il{String[]} in \emph{Java} becomes \il{([Ljava/lang/String;)V}, where the left bracket means an array of whatever type follows, and the colon separates arguments. Naturally, \il{java/lang/String} is a string, and \il{V} stands for the \il{void} type.
	\addtocounter{enumi}{1}
	\item The JVM is stack-based, so line 4 creates a new instance of the \emph{Java} class, whose name is stored in the compiler's symbol table, and the result is left on top of the JVM stack.
	\item Line 5 duplicates whatever is on top of the stack, since the newly created \emph{Java} class will be needed twice, namely for a call on it to \il{init}, and another on \il{run}. These two calls are made in lines 6 and 7, respectively. Notice both method signatures take no arguments and return nothing, hence are equivalent to \il{()V} in bytecode.
	\addtocounter{enumi}{2}
	\item Finally, a return statement is added to the \il{main} method's body, which is omitted in void \emph{Java} methods, but required in bytecode.
	\item A bytecode method requires that the maximum number of elements the stack will have, as well as the total number of local variables in the method be computed. ASM will do that automatically by passing \il{ClassWriter.COMPUTE_FRAMES} as an argument to the constructor of \il{ClassWriter}. The two arguments to \il{mv.visitMaxs} are the maximum stack size, and the total number of local variables. Zeros are passed here since ASM is computing them later, but the call must be made nonetheless.
\end{enumerate}

\section{Generating Declarations}

Overriding the \il{generate} method inside an assignment declaration is straightforward, and consists of making a call to \il{expression.generate}, which causes the expression value to be left on top of the JVM stack, after which a switch statement determines the expression type, and uses the appropriate JVM instruction to store the variable. For integers and booleans it uses \il{ISTORE}, for floats it uses \il{FSTORE}, and for all other types in \emph{Scandal} it uses \il{ASTORE}. Similarly, the \il{generate} method in lambda literal declarations calls \il{lambda.generate}, which causes a lambda literal expression to be left on top of the JVM stack. This expression is then bound to the \il{identToken.text} property using the \il{PUTSTATIC} bytecode instruction. The overridden \il{generate} method in field declarations is identical to that of \il{LambdaLitDeclaration}. In the \il{generate} method, parameter declarations do nothing, since there is no value that can be bound to the declaration's identifier at the moment. Naturally, these values will exist in the context of a lambda application.

\section{Generating Statements}

Even though import statements belong to the AST, no bytecode is ever generated for them. The \il{generate} method still needs to be implemented for being abstract, but simply nothing is done there. The \il{generate} method for assignment statements, on the other hand, is somewhat more complicated, since the \il{Function} interface in \emph{Java} only handles classes and not primitive types. This restriction applies in \emph{Scandal} to integers, floats, and booleans, which are implemented as primitives, and must therefore be wrapped in a \emph{Java} class, namely \il{Integer}, \il{Float}, and \il{Boolean}, in order to be assigned to parameters in a lambda literal expression. The other three types in \il{Scandal}, namely strings, arrays, and lambdas, all correspond to class types in \emph{Java}, hence do not require any conversion. Before assigning to any variable, an expression value is always left on top of the JVM stack. Whenever assigning to a parameter variable inside a lambda literal expression or block, if the expression's type corresponds to a primitive type in \emph{Scandal}, this primitive sitting on top of the JVM stack is wrapped into the appropriate \emph{Java} class. That is done by testing whether the \il{declaration} property inside the assignment statement class is an instance of \il{ParamDeclaration}, which immediately tells the variable is a parameter to a lambda. Otherwise, a test is performed to determine if the \il{declaration} is an instance of \il{FieldDeclaration}, in which case the \il{PUTSTATIC} bytecode instruction is used to assign the expression to the variable. If both tests fail, then the variable must be local, either in the context of \il{run} or local to a lambda body, hence the appropriate store call is made based on the variable type, similarly to assignment declarations. Here a slot number is needed, but that is conveniently stored in the \il{declaration} property, which computed it during its decoration phase.

Generating an indexed assignment statement is done a little differently from the \il{AssignmentStatement} superclass in it involves loading the array first on top of the JVM stack, which is done by asking the \il{declaration} property for a slot number and calling \il{ALOAD}. After that, the \il{index} property is asked to generate itself. If the index is a float, the \il{F2I} instruction is called, which effectively pops the float and pushes its integer part on top of the JVM stack. Similarly, the \il{expression} property is asked to generate itself and, if needed, converted to float by calling the \il{I2F} JVM instruction. Finally, the \il{FASTORE} instruction is used to assign the value on top of the stack to the array at the desired index, eventually popping the three topmost elements from the JVM stack. The \il{generate} method naturally differs between both types of conditional statement. The entire process of generating an if-statement is described in Listing \ref{alg:if}.

\begin{lstlisting}[language=Java,caption={Generating If-Statements.},label={alg:if}]
public void generate(MethodVisitor mv, SymbolTable symtab) throws Exception {
	expression.generate(mv, symtab);
	mv.visitInsn(ICONST_1);
	Label label = new Label();
	mv.visitJumpInsn(IF_ICMPNE, label);
	block.generate(mv, symtab);
	mv.visitLabel(label);
}
\end{lstlisting}

\begin{enumerate}
	\addtocounter{enumi}{1}
	\item Line 2 asks the expression to generate itself, after which its value will be left on top of the JVM stack.
	\item Line 3 loads a constant of value true, given by the \il{ICONST_1} instruction, on top of the stack. Interestingly, integer constants are used in the bytecode implementation of booleans, but not in \emph{Java}. Nor in \il{Scandal}, mostly for clarity.
	\item An instance of \il{org.objectweb.asm.Label} is then created which, upon a call to \il{mv.visitLabel} in line 7, creates a bytecode label instruction.
	\item Before visiting the label, though, both elements on top of the stack are compared by making a call to an \il{IF_CMPNE} jump, and giving it the label just created as an argument. When called, it will pop both topmost elements and jump to the label if these elements are not equal. Since at least one of them has value true, namely the one in line 3, the jump is performed only if the condition is false.
	\item What is jumped over is exactly the contents of the block, thus the block is generated in line 6 still before the label is visited. Generating a block requires simply iterating over its \il{nodes} array, asking each node to generate itself.
\end{enumerate}

Generating while-loops is analogous, but requires two labels, since the loop keeps jumping back to the first label while the condition is true. Naturally, the first label is visited first, to establish that jump location. Then, the expression and a constant of value true are pushed, followed by a call to \il{IF_CMPNE}, as with if-statements, passing as an argument the second label, which is yet to be visited. Next, the block is visited and a \il{GOTO} instruction is added, giving it the first label as an argument, which causes the condition to be re-evaluated. If still true, the block is repeated. If not, a jump to the second label is performed, whose visit is the last step in generating a while-loop. The actual bytecode implementation often involves more instructions. Generation thereof is gladly delegated to the ASM library.

Generating print statements depends on whether the \emph{Scandal} program is running inside the IDE, or in the command line. A call to \il{Platform.isFxApplicationThread} is made to check. If running on the command line, \il{mv} is used to load \il{System.out}, the expression is asked to generate itself on top of it, and finally \il{mv} is used again to call \il{println} on \il{System.out}. If running on the IDE, \il{mv} is used to load \il{language.ide.MainView.console}, which is an instance of \il{javafx.scene.control.TextArea}. The top of the stack is then duplicated, for reasons explained momentarily. The expression is then generated on top of that, and a test is made to see if the expression is not of type \il{string}, in which case a call is made to \il{String.valueOf}, since \il{TextArea} can only append to its contents a value of type \il{java.lang.String}. To actually append the string to whatever the console is displaying at the moment, a call is made to \il{TextArea.appendText}, which pops the two topmost elements, namely the expression and the duplication of the console. A new-line character is then pushed, and a call is made to \il{TextArea.appendText}, in order to create a line break. This causes the top of the stack to be popped twice, hence why the console was duplicated.

The generation phase for plot statements consists of checking, similarly to print statements, whether the program is running on the IDE. If not, no bytecode is generated, hence one cannot see plots when running a \emph{Scandal} program from the command line. Otherwise, we \il{mv} is used to push a new instance of \il{language.ide.PlotTab}, and all three expressions are pushed on top of it. If the last expression has type float, the \il{F2I} instruction is used, and finally \il{init} is called on the \il{PlotTab}, causing it to be displayed on the IDE's main view.

Like before, generation of play statements involves checking whether the program is running inside the IDE. If not, \il{mv} is used to push a new instance of \il{AudioTask} onto the stack, which is duplicates, since it need to be used twice. A call to \il{init} on the \il{AudioTask} follows, which pops the topmost of the two. Both expressions are then generated, and a call to \il{play} on the \il{AudioTask} is made. If the program is running on the IDE, however, a new instance of \il{language.ide.WaveTab} is pushed instead. Next, a string is pushed containing the class name, which the symbol table holds, both expressions are generated, and call is made to \il{init} on the \il{WaveTab}. The string containing the class name is used as the tab's label. The \il{WaveTab} class in the IDE is a subclass of \il{PlotTab}, and displays a plot of the array of samples, decimated to 1000 samples, in addition to playing it back, hence there one never needs to plot \il{and} play in a \emph{Scandal} program. The code-generation routine in write statements uses \il{mv} to push a new instance of \il{framework.generators.AudioTask}, which is duplicated. After calling \il{init} on the \il{AudioTask}, all expressions are pushed and \il{export} is called on \il{AudioTask}, which effectively saves the audio buffer as a \emph{.wav} at the specified path.

\section{Generating Expressions}

Generating binary expressions is unsurprisingly involved, given that operators are \emph{not} overloaded in bytecode at all, hence a fair amount of work is needed to guarantee operators are matched with compatible types. The basic mechanism is to load the left expression, then create a switch case for each kind of operator. The procedure for all arithmetic operators is very similar. After pushing the left expression, a check is made to see if the binary expression has type float. If so, then at least one of the expressions must have type float. So while the left expression is still on top of the stack, \il{generate} checks if it is \emph{not} a float, and if so calls the \il{I2F} instruction. Next, the right expression is pushed and the same check is performed. The last step is to call the appropriate JVM instruction to deal with the float case of the arithmetic operator at hand. If, on the other hand, the binary expression has integer type, then necessarily \emph{both} expressions also have integer type, so \il{generate} just pushes the second expression and calls the appropriate JVM instruction. In the cases where the operation involves a logical operator, the JVM can only perform those operations on integers, including naturally integer representations of booleans. So here the left expression is loaded and cast to integer if it is a float, the same for the right expression, and the logical operator's instruction is called. Comparison operators are more tricky, since \il{generate} cannot count on the overall type of the binary expression to make necessary conversions, and the JVM does have separate instructions for integers and floats, requiring both sides to have the same type. Every binary expression whose operator is a comparison has type boolean, but still, JVM instructions are not overloaded. Hence the top of the stack needs to have agreeing types before a particular instruction is called. However, observing that after calling the operator instruction, the top of the stack is always left with an expression of type boolean, instead of testing every possible case, \il{generate} casts both expressions to float, as needed, and only resorts to float comparisons.

Generation of unary expressions starts by pushing the expression on top of the stack. It then looks at the expression type and covers three cases. If it is an integer, then from type-checking it is only possible that the given operator is a \texttt{MINUS}, hence \il{generate} calls the \il{INEG} instruction. The same applies for floats, only that the \il{FNEG} instruction is called. Code generation is surprisingly more involved for the boolean case. If given a boolean expression, then it needs to be negated. That is accomplished by creating two labels, visiting an \il{IFEQ} jump instruction, and giving it the first label as an argument, which causes the top of the stack to be popped. If the stack contained a zero, that is, if the expression evaluates to false, then a jump to the first label is performed, where a \il{ICONST_1} is pushed onto the stack. If the stack contained a true instead, then a \il{ICONST_0} is pushed, and \il{generate} visits a \il{GOTO} jump, giving it as an argument the second label. At the second label location, nothing is really done, and \il{generate} just leaves the false value on top of the stack and returns.

Generating identifier expressions resorts to three cases. The first case is when the declared variable is a field, which is known from the \il{isField} property every declaration contains. If so, \il{generate} use \il{mv} to push the value associated with the field's name. The second case deals with the possibility that the variable is a parameter inside a lambda, which happens whenever the \il{declaration} property is an instance of \il{ParamDeclaration}. If so, then surely the value of the expression is not a primitive, since the \il{Function} interface requires values to be passed as classes, as discussed previously. The \il{generate} method then does two things, namely it uses \il{ALOD} to push the expression's value, then calls \il{Expression.getTypeValue}, a static method that converts from classes left on top of the stack to their primitive values. Naturally, this only applies to integers, floats, and booleans. If neither a field, nor a parameter, then \il{generate} loads the variable normally. For integers and booleans, it uses \il{ILOAD}, for floats \il{FLOAD}, and for all other types it uses \il{ALOAD}. Except for fields, a slot number is always needed to load variables, which is retrieved from the \il{declaration} property every identifier expression contains.

Code generation of literal expressions is easy. For integers and floats, \il{generate} calls respectively \il{Integer.parseInt} and \il{Float.parseFloat}, using the result as an argument to \il{mv.visitLdcInsn}, which effectively pushes the value onto the stack. There is no risk of finding bad numbers here, as a check has already been made during scanning. For booleans, \il{generate} tests the given keyword, and loads the appropriate constant, whereas for strings, it uses \il{mv} to load the \il{firstToken.text} property directly.

Generating array literal expressions requires constructing the array, element by element, on the JVM stack. To do so, \il{generate} uses \il{mv} to push the size of the list of floats onto the stack, then calls the \il{NEWARRAY} instruction with a \il{T_FLOAT} argument. It then iterates over the list of floats and, for each expression, duplicates the top of the stack, pushes an index value onto the stack, asks the expression to generate itself, converting it to float as needed, and finally calls the \il{FASTORE} instruction, which stores the expression's value onto the new array at the specified index. At the end of the each iteration, the call to \il{FASTORE} pops the topmost two elements, hence at the end of the entire process, \il{generate} effectively leaves the filled-up array on top of the stack. Generation of array item expressions asks the \il{array} property to push itself onto the stack, then asks the \il{index} property to do the same. If the index has type float, \il{generate} calls \il{F2I}, as usual. Finally, \il{generate} uses \il{mv} to call \il{FALOAD}, leaving a float on top of the stack. Generation of array size expressions is also easy, asking the \il{array} property to load itself, then using \il{mv} to call the \il{ARRAYLENGTH} instruction. Code generation of new array expressions loads the \il{size} property on top of the stack and converts it to integer, as needed, finally calling the \il{NEWARRAY} instruction with a \il{T_FLOAT} argument, similarly to array literal expressions.

Code generation of pi expressions is trivial, with \il{generate} simply asking \il{mv} to load \emph{Java}'s \il{Math.PI} on top of the stack. Generation of cosine expressions asks the \il{phase} property to leave a value on top of the stack, then converts it to double using either the \il{F2D} or the \il{I2D} instruction, since the method signature for \emph{Java}'s \il{Math.cos} takes a double and returns a double. It then uses \il{mv} to invoke \il{Math.cos}, finally casting the result back to float using \il{D2F}. For power expressions, the method signature for \il{Math.pow} in \il{Java} takes two doubles and returns one, so \il{generate} converts back and forth, similarly to what is done in cosine expressions. Floor expressions follow the same pattern, only by invoking \emph{Java}'s \il{Math.floor} method instead. For write expressions, code generation asks \il{mv} to create a new instance of \il{WaveFile}, which is duplicated. It then generates the \il{path} property and calls \il{init} on \il{WaveFile}. Next, \il{generate} pushes the \il{format} property and calls \il{WaveFile.get}, which leaves an array of floats on top of the stack. Code generation of record expressions is very similar to read expressions, where \il{generate} instantiates an \il{AudioTask}, duplicates it, and calls \il{init}. It the pushes the \il{duration} property onto the stack, which is given in milliseconds, and casts it to integer, as needed, finally calling \il{AudioTask.record}. The latter will block execution of the \il{Scandal} thread for the entire \il{duration}, capture input from the preferred audio input device in \il{Settings}, then leave an array of floats on top of JVM the stack.

\section{Generating Lambdas}

Code generation of lambda literal expressions is a lot more involved than expressions in general, and accomplished in two stages. In the first stage, an instance of \il{Program} calls the \il{generate} method overridden from \il{Node}, giving it as an argument the instance of \il{MethodVisitor} associated with the \emph{Java} class' \il{init} method. The purpose of the code generated inside \il{init} is to associate the lambda declared as a field with a method body. Every lambda literal implements the \il{Function} interface, which is a \emph{Java} functional interface, so called whenever they comprise a single abstract method, and any number of methods containing bodies. Thus an object that implements the \il{Function} interface needs to be instantiated for each lambda literal declared. This object will in turn implement the interface's abstract method, which is matched to the expression or block held inside each \il{LambdaLitExpression}. This object can thereafter be treated as a variable. Whenever a lambda expression is applied arguments or composed with other lambda expressions, the JVM is basically calling methods on this class. Note that the one abstract interface method is however a static and synthetic method of the class that \emph{defines} the implementor of the functional interface, and not part of the implementing object itself. For this reason, type-checking inside the JVM is deferred until runtime, hence \il{generate} uses the \il{INVOKEDYNAMIC} instruction to call \il{java.lang.invoke.LambdaMetafactory}, which does all the heavy lifting, instead of doing all the above wiring explicitly. In \emph{Java}, lambda expressions are essentially syntactic sugar for objects that implement functional interfaces.

Inside the first stage of code generation, a string is formed containing the lambda's method signature. This method signature consists of a single input type and a return type. The reason for a single input parameter, despite the size of the parameter list, is the right-associated currying of lambda expressions described above, in which a function of $n$ variables that returns a value is seen as a function of one variable that returns a function of $n - 1$ variables, and so on until a function of one variable that returns a value, when the last variable is reached. It follows the required method signature always has as input type the type of its very first argument, always given as a \emph{Java} class, as \il{Function} accepts no primitive types. The return type depends on the size of the argument list, naturally. If only one argument is given, then the expression's return type is the type of the return expression, otherwise the return type is \il{java.util.function.Function}. Having formed this string, \il{generate} uses it as an argument to \il{mv.visitInvokeDynamicInsn}, which effectively wires the lambda body pertaining to the \emph{Java} class to the \il{apply} method in the object that implements the \il{Function} interface, making use of \il{LambdaMetafactory}.

The second phase of code generation consists of writing the bytecode for the lambda body itself. The \il{LambdaLitExpression} class overloads the \il{generate} method in \il{Node} to take as parameters an instance of \il{SymbolTable} and an instance of \il{ClassWriter}. The latter is used to create an instance of \il{MethodVisitor} that includes the lambda body as a method in the \emph{Java} class. If the lambda expression has more that one parameter, \il{generate} actually needs to instantiate a method visitor, as well as include a method in the \emph{Java} class for each parameter in the list, as discussed previously. These methods all have three flags, namely private, static, and synthetic, and are named by incrementing \il{lambdaSlot}. In only the very last of the methods does \il{generate} ask for the return expression to generate itself. For all the others, it pushes onto the stack all parameters up the the current, and calls the \il{apply} method inherited from the \il{Function} interface, which leaves an instance of \il{Function} on top of the stack. For all these methods, \il{generate} gives the \il{ARETURN} instruction and uses ASM to compute the sizes of the JVM frame and local variable count.

The first stage of generation in a \il{LambdaLitBlock} is identical to the \il{LambdaLitExpression} superclass, hence it is not overridden. The second phase of code generation, the one in which the redirected method body is written to the bytecode class, is not identical but very similar to the superclass'. The only difference is that, instead of asking a return expression to decorate itself at the body of the lambda associated to the rightmost parameter, \il{generate} asks for the lambda block to generate itself. Code generation of return blocks also differ from the superclass implementation in that, in addition, they ask the return expression to generate itself before returning.

The code generation phase of lambda application expressions is simpler, and begins by asking the \il{lambda} property to generate itself. Next, \il{generate} iterates over the argument list and, like in decoration, offsets the list of parameters by its current size minus \il{count}, asking each argument to generate itself. If the argument passed is a literal, \il{generate} casts it to the corresponding \emph{Java} class, since the \il{Function} interface does not accept primitive types. Also, for each argument, \il{generate} calls \il{Function.apply}, which effectively calls the method associated to each parameter of the original lambda literal. The last step of generating each parameter consists of verifying that the returned value left on top of the JVM stack corresponds to what is expected, which is done by calling the \il{CHECKCAST} instruction. There are three possibilities. In the case we are the application of a lambda that is a parameter to another lambda, \il{generate} simply trusts that the assignment declaration or statement that has this lambda application as its expression has already decorated it with a type, so \il{generate} uses the \il{this.type} property to make the check. Otherwise, \il{generate} can use \il{lambdaLit.returnExpression.type} for the very last argument being visited, or \il{Types.LAMBDA} for all others. After generating and applying all arguments, \il{generate} leaves a \il{Java} class on top of the stack, but a literal should be left if the expression type corresponds to one of \emph{Scandal}'s literal types. If so, \il{generate} casts the result back to a primitive and returns.

Generating lambda compositions is, on the other hand, rather straightforward, and begins by pushing the very first expression onto the stack. Next, for each lambda other than the first, \il{generate} pushes it onto the stack and calls \il{Function.andThen}, which consumes the top two elements and leaves the result on top of the stack. The last step of code generation consists of checking whether the \il{lambdaApp} property is null. If not, \il{generate} loads its arguments, check-casting and applying each one, and converts the result to a primitive, as needed, exactly the same way arguments in a \il{LambdaAppExpression} are loaded and applied. Otherwise, \il{generate} simply leaves the last result of \il{Function.andThen} on top of the stack and returns.