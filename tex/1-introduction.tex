\chapter{INTRODUCTION}

Formal languages lend precision and flexibility to music specification because they require that musical ideas be turned into abstract symbols and stipulated explicitly.

Herein lies both the advantage and disadvantage of linguistic interaction with a computer music system.

The advantage is that formalized and explicit instructions can yield a high degree of control.

To create an imagined effect, composers need only specify it precisely.

They can easily stipulate music that would be difficult or impossible to perform by human beings.

In some cases, a linguistic specification is much more efficient than gestural input would be.

This is the case when a single command applies to a massive group of events, or when a short list of commands replaces dozens of pointing and selecting gestures.

The shell scripts of Unix operating systems are a typical example of command lists (Thompson and Ritchie 1974).

These advantages turn into a disadvantage when simple things must be coded in the same detail and with the same syntactic overhead as complicated things.

For example, with an alphanumeric language, envelope shapes that could be drawn on a screen in two seconds must be plotted out on paper by hand and transcribed into a list of numerical data to be typed by the composer.

For many tasks, graphical editors and visual programming systems, in which the user selects and interconnects graphical objects, are more effective and easier to use than their textual counterparts (see chapter 16).

Some languages are interactive; one can type individual statements and each of them is interpreted in turn.

This can occur in a concert situation, but the slow information rate of typing — not to mention the mundane stage presence of a typist — precludes this approach in fast­paced real­time music­making.

Gestural control through a musical input device is more efficient and natural.

Hence, languages for music, although important, do not answer all musical needs.

In the ideal, music languages should be available alongside other kinds of musical interaction tools.

\cite[785-786]{Roads1995}.

Textual languages are a precise and flexible means of controlling a computer music system.

In synthesis, score entry, and composition, they can liberate the potential of a music system from the closed world of canned software and preset hardware.

In the mid­-1980's it looked as if the Music N synthesis language dynasty might languish, due to the spread of inexpensive synthesizers.

In MIDI systems, however, the use of a score language is less common, since most music can be entered by other means (such as a music keyboard, notation program, or scanner).

For musicological applications that involve score analysis, however, a text­-based score representation may be optimum.

New textual languages for procedural composition continue to be developed, but there is a strong parallel trend toward interactive programs with graphical interfaces.

Instead of typing text, one patches together icons, draws envelopes, and fills in templates.

The textual language representation supporting the graphics is hidden from the user.

Early programming languages for music tended to favor machine efficiency over ease of use.

The present trend in programming has shifted from squeezing the last drop of efficiency out of a system to helping the user manage the complexity of layer upon layer of software and hardware.

The most common solution to this problem is object­-oriented programming (see chapter 2), and compositional applications are no exception to this trend (Pope 1991b).

\cite[817]{Roads1995}.

% Chapter: Description of Scandal
% 	Describes the language and what it can do.
% 	Include the concrete syntax and code snippets as examples.
% 	Little or nothing about the implementation goes here.
% 	Someone should be able to read this chapter and have a reasonably good idea of how to use Scandal.
% 	Mostly from the point of view of a user

\chapter{AN OVERVIEW OF \emph{SCANDAL}}

\section{The Concrete Syntax of \emph{Scandal}}

\subsection{Top-Level Productions}

At the topmost level of a \emph{Scandal} program, there are basically only two kinds of constructs that are allowed, namely declarations and statements. The legal declarations at this level are further subdivided into three: assignment declarations, field declarations, and lambda literal declarations. There is a fourth type of declaration, the paramenter declaration, that is not allowed as a top-level construct. In the productions that follow, the star symbol represents a \emph{Kleene} star, and or-symbols and parenthesis are not tokens in the language. As a rule, terminal symbols will be given by their names, like \texttt{OR}, to avoid confusion with symbols in the language's grammar. Below are the production rules for \il{program}. We here present terminal symbols in the syntactical context in which they appear. %A complete list of terminal symbols can be found in Sec.~\ref{sec:symbols}.

In the discussion that follows, terminal symbols are in all-capital letters, productions in the concrete syntax begin with a lower-case letter, and their counterparts in the abstract syntax begins with an upper-case letter.

It follows every variable declaration in \emph{Scandal} must be initialized, except when they are parameters of a lambda literal, in which case they actually cannot be initialized.

Even blocks are not allowed on their own, and may only occur in the context of a statement or lambda literal expression.

Expressions in \emph{Scandal} cannot be evaluated on their own, rather existing only in the context of a declaration or statement.

It should be immediately apparent that indexed arrays in \emph{Scandal} must have the array necessarily bound to a name, and an expression like $[1, 2, 3][0] == 1$ is not allowed at all.

Not requiring that all entries be floats greatly improves the language, as we can freely mix integers an floats while declaring them as a comma-separated list. Since we require expressions and not necessarily literal expressions, such an array as \il{[1, pow(2, 3.2), 3.5, pi]} would be perfectly legal.

At the moment, there is no simple mechanism to fix a parameter in the middle, given this enforced right-associativity. There is, however, a workaround where one declares a new lambda literal that returns an application of the lambda whose middle parameter we want to fix. The parameters in this new lambda literal are essentially the same, but reordered so that the fixed parameter is the leftmost, as seen in Listing \ref{alg:reorder}.

\begin{lstlisting}[emph={field,int,lambda,print},emphstyle={\textbf},caption={Right associativity of lambda expressions.},label={alg:reorder}]
field int w = 1
lambda f = int x -> int y -> int z -> x + y + z
lambda g = int x -> int z -> f(x, w, z)
\end{lstlisting}

The \il{Function} interface has two non-abstract methods that deal with function composition, the other is \il{Function.compose}. The difference is the order in which we compose functions. \il{Function.compose} corresponds to the mathematical notation $f \circ g(x) = f(g(x))$, in which we evaluate $g$ first. \il{Function.andThen} does the same in reversed order, and is preferred in \emph{Scandal} for being more intuitive.

As will be seen below, every \il{declaration} begins with a type token, or with a \il{field} flag, followed by a type token

\begin{itemize}
	\item types := \texttt{KW\_INT} $|$ \texttt{KW\_FLOAT} $|$ \texttt{KW\_BOOL} $|$ \texttt{KW\_STRING} $|$ \texttt{KW\_ARRAY} $|$ \texttt{KW\_LAMBDA}
	\item declaration := assignmentDeclaration $|$ fieldDeclaration
	\item declaration := lambdaLitDeclaration $|$ paramDeclaration
	\item program := (assignmentDeclaration $|$ fieldDeclaration)$^*$
	\item program := (lambdaLitDeclaration $|$ statement)$^*$
\end{itemize}

Below are the production rules for the concrete syntax of declarations in \emph{Scandal}.

\begin{itemize}
	\item paramDeclaration := types \texttt{IDENT}
	\item assignmentDeclaration := types \texttt{IDENT} \texttt{ASSIGN} expression
	\item fieldDeclaration := \texttt{KW\_FIELD} types \texttt{IDENT} \texttt{ASSIGN} expression	
	\item lambdaLitDeclaration := \texttt{KW\_LAMBDA} \texttt{IDENT} \texttt{ASSIGN} lambdaLitExpression
	\item lambdaLitDeclaration := \texttt{KW\_LAMBDA} \texttt{IDENT} \texttt{ASSIGN} lambdaLitBlock
\end{itemize}

Below are the productions for the concrete syntax of \emph{Scandal} statements.

\begin{itemize}
	\item statement := importStatement $|$ assignmentStatement $|$ indexedAssignStat
	\item statement := ifStatement $|$ whileStatement $|$ printStatement
	\item statement := playStatement $|$ plotStat $|$ writeStat
	\item importStatement := \texttt{KW\_IMPORT} \texttt{LPAREN} expression \texttt{RPAREN}
	\item assignmentStatement := \texttt{IDENT} \texttt{ASSIGN} expression
	\item indexedAssignStat := \texttt{IDENT} \texttt{LBRACKET} expression \texttt{RBRACKET} \texttt{ASSIGN} expression
	\item ifStatement := \texttt{KW\_IF} expression block
	\item whileStatement := \texttt{KW\_WHILE} expression block
	\item block := \texttt{LBRACE} (assignmentDeclaration $|$ statement)$^*$ \texttt{RBRACE}
	\item printStatement := \texttt{KW\_PRINT} \texttt{LPAREN} expression \texttt{RPAREN}
	\item playStatement := \texttt{KW\_PLAY} \texttt{LPAREN} expression \texttt{COMMA} expression \texttt{RPAREN}
	\item plotStat := \texttt{KW\_PLOT} \texttt{LPAREN} expression \texttt{COMMA} expression \texttt{COMMA} expression \texttt{RPAREN}
	\item writeStat := \texttt{KW\_WRITE} \texttt{LPAREN} expression \texttt{COMMA} expression \texttt{COMMA} expression \texttt{RPAREN}
\end{itemize}

The concrete syntax rules for the various types of expressions reflect this fact in the sense that \emph{every} subclass of \il{Expression} is treated while parsing as a binary tree, even if it eventually turns out to be a trivial, single-leaf tree. The leaves are called factors in the production rules below. Above factors, there can be summands, and above summands there can be comparisons, depending on the precedence of the connecting operators. In \emph{Scandal}, we do not allow carets or double-stars for exponentiation. Should we do allow them in the future, they would need to be introduced in the rules below with a higher precedence than factors, that is, powers would need to replace factors as leaves.

\begin{itemize}
	\item expression := comparison (comparisonOp comparison)$^*$
	\item comparisonOp := \texttt{LT} $|$ \texttt{LE} $|$ \texttt{GT} $|$ \texttt{GE} $|$ \texttt{EQUAL} $|$ \texttt{NOTEQUAL}
	\item comparison := summand (summandOp summand)$^*$
	\item summandOp := \texttt{PLUS} $|$ \texttt{MINUS} $|$ \texttt{OR}
	\item summand := factor (factorOp factor)$^*$
	\item factorOp := \texttt{TIMES} $|$ \texttt{DIV} $|$ \texttt{MOD} $|$ \texttt{AND}
	\item factor := derivedExpression $|$ literalExpression $|$ arrayExpression
	\item factor := frameworkExpression $|$ lambdaExpression
\end{itemize}

Derived expressions are those defined in terms of another expression. They exist in three contexts, namely when an expression is surrounded by parenthesis, when we wish to negate a number or logically \emph{or} a boolean expression, and as name references to other expressions. Below are the concrete rules for derived expressions.

\begin{itemize}
	\item derivedExpression := parethesizedExpression $|$ unaryExpression $|$ identExpression
	\item parethesizedExpression := \texttt{LPAREN} expression \texttt{RPAREN}
	\item unaryExpression := (\texttt{MINUS} $|$ \texttt{NOT}) expression
	\item identExpression := \texttt{IDENT}
\end{itemize}

Literal expressions are the simplest constructs in the language, since their values are not computed. They are naturally leaves in binary expression trees, and are thus parsed in the \il{factor} method. Their concrete rules are very simple, thus instantiating an appropriate AST class simply requires we look for the appropriate token kind. The abstract syntax rules are identical, with an instance of \il{Token} instead of a character string, and are thus omitted. Below are the concrete rules for literal expressions.

\begin{itemize}
	\item literalExpression := intLitExpression $|$ floatLitExpression
	\item literalExpression := boolLitExpression $|$ stringLitExpression
	\item intLitExpression := \texttt{INT\_LIT}
	\item floatLitExpression := \texttt{FLOAT\_LIT}
	\item boolLitExpression := \texttt{KW\_TRUE} $|$ \texttt{KW\_FALSE}
	\item stringLitExpression := \texttt{STRING\_LIT}
\end{itemize}

In the productions above, we note that non-zero integer literals are not allowed to start with a zero. In such a scenario, even though the scanner will create two tokens, one for the zero, and another for the rest of the number, since there are no productions in the language that take two integers separated by white space, the parser inevitably will throw a compilation error. The same applies to floating-point decimals, where only one zero can come before the dot. In this particular case, a zero actually \emph{must} precede the \texttt{DOT} token, and such constructs as $x = .5$ are not allowed. Doubles, shorts, or longs do not exist in \emph{Scandal} as of yet, and there is no need to declare float literals the way they are in \emph{Java}, with $1.1f$ for float and $1.1$ for double, say. In fact, that will cause an error. As previously mentioned, string literals are constructed by enclosing text within quotes, and the use of apostrophes will cause a scanning error. Even though quotes are in the language's alphabet, they are discarded upon conversion into an instance of \il{Token}, as their only possible use is within a string literal. \texttt{DOT}, on the other hand, has uses besides separating the decimal part of a \texttt{FLOAT\_LIT}, namely in composed lambdas. Hence the scanner simply instantiates a token and delegates the inferring of meaning to the parser, in this case. Boolean literals are quite self-explanatory, and we note booleans are not allowed to replace numbers in arithmetic expressions. As seen in the discussion on binary expressions, arithmetic operators are not overloaded to accept booleans. For all other operators, though, numbers and booleans can be used in the same expression. Also, unlike \emph{C}, numbers alone are not allowed to replace booleans in control statements.

Array expressions are fundamental to the DSL in that sound data is processed as arrays of floats. There are four types of array expression, namely literal ones, which are declared as comma-separated numbers surrounded by brackets, array items, which are floats retrieved from an array at a particular index, array sizes, which are integers corresponding to sizes of arrays, and lastly array constructors, which create arrays of zeros with a given integer size. Below are the concrete rules.

\begin{itemize}
	\item arrayExpression := arrayLitExpression $|$ arrayItemExpression
	\item arrayExpression := arraySizeExpression $|$ newArrayExpression
	\item arrayLitExpression := \texttt{LBRACKET} expression (\texttt{COMMA} expression)$^*$ \texttt{RBRACKET}
	\item arrayItemExpression := identExpression \texttt{LBRACKET} expression \texttt{RBRACKET}
	\item arraySizeExpression := \texttt{KW\_SIZE} \texttt{LPAREN} expression \texttt{RPAREN}
	\item newArrayExpression := \texttt{KW\_NEW} \texttt{LPAREN} expression \texttt{RPAREN}
\end{itemize}

Framework expressions, like framework statements, provide functionality to \emph{Scandal} that would be impractical to implement in terms of the language alone. In some cases, though, they are just conveniences, like providing a keyword for the number pi. As discussed previously, this practice always imposes a trade-off, as by not allowing the language to grow in terms of itself, we inevitably experience compiler bloat. Many framework statements and expressions will likely be bootstrapped into the language as it evolves, except perhaps those have a direct correspondence to a JVM instruction, rather than to a \emph{Java} class. The primary difference between framework statements and expressions is that the latter leaves some value on top of the JVM stack to be consumed. Below are the concrete rules for framework expressions.

\begin{itemize}
	\item frameworkExpression := piExpression $|$ cosExpression $|$ powExpression
	\item frameworkExpression := floorExpression $|$ readExpression $|$ recordExpression
	\item piExpression := \texttt{KW\_PI}
	\item cosExpression := \texttt{KW\_COS} \texttt{LPAREN} expression \texttt{RPAREN}
	\item powExpression := \texttt{KW\_POW} \texttt{LPAREN} expression \texttt{RPAREN}
	\item floorExpression := \texttt{KW\_FLOOR} \texttt{LPAREN} expression \texttt{RPAREN}
	\item readExpression := \texttt{KW\_READ} \texttt{LPAREN} expression \texttt{COMMA} expression \texttt{RPAREN}
	\item recordExpression := \texttt{KW\_RECORD} \texttt{LPAREN} expression \texttt{RPAREN}
\end{itemize}

In the spirit of saving the best for last, we now discuss lambda expressions. \emph{Scandal} is not a pure functional language, however lambdas are the sole mechanism for defining methods in the language. Being that \emph{Scandal} is a statically-typed scripting language where we do not explicitly define new types, lambdas, as well as applications and compositions thereof are in effect an essential part of the language in what regards encapsulation and code re-usability in general. As we shall see in the next chapter, one can write an entire musical composition in \emph{Scandal} using only lambda expressions. There are four types of lambda expressions, of which two are literal. Literal lambda expressions differ from the other types in that they define a method body, either as a simple expression to be returned, or as an entire block, which in turn contains a return expression as its last statement. As previously discussed, literal lambda expressions, for the moment, are always global variables. They can nonetheless be copied into local variables, and accessed as such. The other two types are applications and compositions. The former has a familiar method-like syntax, with a name reference preceding comma-separated arguments surrounded by parenthesis. The latter has two possible uses, one in which no arguments are given, in which case we have a list of name references connected by dots. The second use includes a list of arguments, and its syntax is that of a composition followed by a dot and an application. Below are the concrete rules for lambda expressions.

\begin{itemize}
	\item lambdaExpression := lambdaApp $|$ lambdaComp $|$ lambdaLit $|$ lambdaBlock
	\item lambdaApp := identExpression \texttt{LPAREN} expression (\texttt{COMMA} expression)$^*$ \texttt{RPAREN}
	\item lambdaComp := identExpression (\texttt{DOT} identExpression)$^*$
	\item lambdaComp := identExpression (\texttt{DOT} identExpression)$^*$ \texttt{DOT} lambdaApp
	\item lambdaLit := paramDeclaration \texttt{ARROW} (paramDeclaration \texttt{ARROW})$^*$ expression
	\item lambdaBlock := paramDeclaration \texttt{ARROW} (paramDeclaration \texttt{ARROW})$^*$ retBlock
	\item retBlock := \texttt{LBRACE} (assignmentDeclaration $|$ statement)$^*$ retExpression \texttt{RBRACE}
	\item retExpression := \texttt{KW\_RETURN} expression
\end{itemize}

\section{An Overview of Lambda Expressions}

This section gives a brief overview of \emph{Scandal}'s functional capabilities, and is presented first because the subsequent examples will all make use of these core concepts. Listing \ref{alg:lambdas} summarizes the many syntactical constructs associated to lambdas in \emph{Scandal}, which are subsequently described, line by line. Lines 3 to 6 demonstrate currying, partial applications, and compositions; lines 8 to 10 show how literal lambdas may be copied into local or global variables; lines 12 and 13 show compositions may too be copied into local or global variables; lines 15 to 19 give an example of higher-order functions and their type-inference mechanism; finally, lines 21 to 26 demonstrate how lambda literals, applications, and compositions can capture the environment. 

\begin{lstlisting}[emph={field,float,lambda},emphstyle={\textbf},caption={The syntax of lambda expressions in \emph{Scandal}.},label={alg:lambdas}]
field float eleven = 11.0

lambda adder = float x -> float y -> x + y
lambda add4 = adder(4.0)
lambda add6 = adder(6.0)
float twentyOne = add6.add4(eleven)

lambda id = float x -> x
field lambda copy = id
eleven = copy(eleven)

field lambda copyComposition = add4.add6
twentyOne = copyComposition(eleven)

lambda higherOrder = float x -> lambda f -> {
	float val = f(x)
	return val
}
eleven = higherOrder(eleven, id)

lambda captureFloat = float x -> x + eleven
print(captureFloat(eleven))
lambda captureLambda = float x -> copy(x)
print(captureLambda(eleven))
lambda captureComposition = float x -> copyComposition(x)
print(captureComposition(eleven))
\end{lstlisting}

\begin{enumerate}
	\item The mechanism in \emph{Scandal} to capture the environment is to declare external variables as fields. Having been declared as such, \il{eleven} will be accessible inside lambda bodies.
	\addtocounter{enumi}{1}
	\item Functions that take multiple arguments are always curried in \emph{Scandal}. The declaration of \il{adder} is read ``adder is a lambda that takes a float $x$, that returns an anonymous lambda that takes a float $y$, that returns the expression $x + y$''.
	\item Applying arguments to a lambda expression fixes its parameters from left to right. Applying four to \il{adder}, fixes the parameter $x$ and recovers the anonymous function defined by it. Partial applications return functions, which can be freely stored for posterior use.
	\addtocounter{enumi}{1}
	\item Lambdas may be composed when the return type of a lambda matches the input type of the lambda to its right. Here \il{eleven} is being applied to \il{add6}, which returns a float ($11 + 6 = 17$) that is fed to \il{add4}, which in turn returns another float ($17 + 4 = 21$) that is stored to \il{twentyOne}. At the moment, only copies of partial applications may be composed, that is, a lambda composition cannot have arguments preceding a dot.
	\addtocounter{enumi}{1}
	\item Literal lambdas can be copied to local or global (field) variables. The literal lambda \il{id} is always visible, and so is \il{copy}, since it was marked as a field.
	\addtocounter{enumi}{3}
	\item Copying compositions works the same way as copying any other lambda expression. Marking \il{copyComposition} as a field makes it visible inside lambda literal bodies.
	\addtocounter{enumi}{2}
	\item Higher-order functions are those that can take functions as arguments, return functions, or both. \emph{Scandal} supports higher-order functions, but it does not support parameterized types. In line 16, the parameter \il{f} needs to be applied before returned in line 17, so that its input and return types may be inferred by the compiler. \emph{Scandal} still lacks the functionality of returning lambdas directly from function bodies. Lambdas can still return partial applications of themselves.
	\addtocounter{enumi}{5}
	\item When marked as fields, lambdas, as well as any other variable types, become available to every scope of a program. Line 21 demonstrates this behavior with a float, line 23 with a lambda, and line 25 with a lambda composition. Partial applications would have worked the same way.
\end{enumerate}

\section{Basic Input/Output Operations}

Importing audio files in \emph{Scandal} is straightforward, all that is needed is a \il{read} statement and a string pointing to the path of a \emph{.wav} file in the file system. Visualizing array data is also simple with a \il{plot} statement. Playback is performed in real time and set to loop indefinitely, despite the length of the audio buffer. Therefore, for all but very few applications, there should be a single \il{play} statement per \emph{Scandal} program, for each \il{play} statement initiates a new audio thread, which are always different from the thread in which the compiler runs, which in turn is a separate thread from the main user interface thread. Hence multiple \il{play} statements will sound simultaneously. Unlike \il{play}, \il{record} captures from the default audio input by blocking the compiler thread, so that no playback in a given program occurs simultaneously with a recording. Of course, other programs may be playing back in different threads. An implementation of \emph{I Am Sitting in a Room} might require two different \emph{Scandal} programs running at the same time on the IDE. Listing \ref{alg:inout} exemplifies the input/output functionality of \emph{Scandal}.

\begin{lstlisting}[emph={array,read,string,plot,print,record,play,import},emphstyle={\textbf},caption={Inputting and outputting in \emph{Scandal}},label={alg:inout}]
array lisa = read("wav/monoLisa.wav", 1)
plot("A Scandalous Sound File", lisa, 1000)

print("Recording...")
array recording = record(10000)

print("Playing...")
play(recording, 1)
play(lisa, 1)
\end{lstlisting}

\begin{enumerate}
	\item Lines 1 and 2 simply import the audio file in the given path and instantiate a plot tab, decimating the length of the plot to 1000 points.
	\addtocounter{enumi}{2}
	\item Line 4 posts to the console a message to inform the used recording has started, and line 5 saves ten seconds of captured audio data into a buffer. For the duration of the recording, the execution thread will be blocked, and none of the subsequent statements will be executed.
	\addtocounter{enumi}{2}
	\item Line 7 will post to the console that playback has begun, and line 8 starts a real-time audio thread that plays the captured audio back. Since every \il{play} statement runs on its own thread, none of them block the execution thread, and the statement in line 9 will play back simultaneously with the one in line 8.
\end{enumerate}

\section{Array Operations}

This section presents a sampler of \emph{Scandal} implementations of some general-purpose algorithms, with a focus on the language's limitations, which are natural given the specificity of its domain of applications. Many of the programs discussed here come bundled with \emph{Scandal}'s IDE, under the \emph{Examples} tab of its right accordion view. Much of audio signal processing relies on some very general array operations. Among these, modifying the amplitude of an audio signal boils down to simply multiplying a vector by a scalar, the latter naturally between zero and one. Changing the dynamics of an audio buffer is often an algorithmic task, and audio engineers have at their disposal a large palette of techniques which ultimately consist of applying scalars to buffers of audio data. Such techniques include compression, expansion, limiting, dithering, and normalization. Normalizing a buffer of audio data is extremely simple, as the scalar is simply the multiplicative inverse of the maximum element in the array. Since audio samples are represented by floats ranging from minus one to one, care must be taken when testing for the maximum array element, for it could be a negative value. When samples are allowed to take negative values, the absolute value of every sample must be considered, otherwise the result might not be an array whose maximum element is one. Listing \ref{alg:max} describes finding an array's absolute maximum in \emph{Scandal}.

\begin{lstlisting}[emph={lambda,array,float,int,while,size,if,return},emphstyle={\textbf},caption={Computing the maximum element of an array.},label={alg:max}]
lambda max = array x -> {
	float m = x[0]
	float sample = 0
	int i = 0
	while i < size(x) {
		sample = x[i]
		if sample < 0 { sample = -sample }
		if m < sample { m = sample }
		i = i + 1
	}
	return m
}
\end{lstlisting}

Listing \ref{alg:max} is very straightforward to understand. Given that there are no for-loops in \emph{Scandal}, one must declare an iterator outside the while-loop, then increment it inside its block. At the moment, there is no \il{abs} operator either, and computing the absolute value in line 7 can certainly be improved by refactoring that line into another lambda, which could in turn be made available for later use. Rather than bloating the compiler with dozens of mathematical expressions, the preferred avenue is to allow for the language to evolve in terms of itself, and only functions that are more difficult to compute, such as trigonometric functions, are being hard-wired to the compiler at this point. In the spirit of making \emph{Scandal} code as reusable as possible, we declare a \il{scale} lambda whose parameters are an array to be scaled, and a function that determines a scalar in terms of the array itself. The idea is to apply to \il{scale} both an array, and a function that computes the array's absolute maximum element. Then, dividing each element of the array by its maximum will effectively normalize it. For both improved performance and re-usability reasons, we would like to perform multiplications, and not divisions. Hence we need a function that computes the inverse maximum of an array. Listing \ref{alg:inverse} reuses is a generic method that computes the reciprocal of \emph{any} lambda that takes an array and returns a float.

\begin{lstlisting}[emph={lambda,array,float,return},emphstyle={\textbf},caption={Computing the inverse of an \il{array -> float} lambda.},label={alg:inverse}]
lambda inverseLambda = array x -> lambda f -> {
	float val = f(x)
	return 1 / val
}
\end{lstlisting}

The value of \il{f(x)} in Listing \ref{alg:inverse} cannot be returned directly, as line 2 is crucial for the parameterized type inference mechanism of the compiler. The function \il{inverseMax} is the special case of \il{inverseLambda} that deals with computing the reciprocal of an array's maximum. Since lambda literals are always global, we could have defined \il{inverseMax} equivalently by substituting its return expression with the expression \il{1 / max(x)}, and dispensing altogether with \il{inverseLambda}. Normalizing a buffer of audio samples then becomes the single elegant line of \emph{Scandal} code given in line 2 of Listing \ref{alg:normal}. More than concise, the \il{normalize} method leaves all of its constituent parts, that is, every one of its different computational steps, open to be reused and recombined into other functions. That seemingly trivial characteristic of functional programming has in fact very deep implications to digital signal processing in general, and exploring its capabilities is one of \emph{Scandal}'s primary missions. The \emph{lib/Arrays.scandal} library contains many more examples of array operations in \emph{Scandal}, including routines to reverse and splice buffers of audio data.

\begin{lstlisting}[emph={lambda,array},emphstyle={\textbf},caption={Normalizing an array.},label={alg:normal}]
lambda inverseMax = array x -> inverseLambda(x, max)
lambda normalize = array x -> scale(x, inverseMax)
\end{lstlisting}