\chapter{THEORETICAL FRAMEWORK}

In this chapter, we present and discuss the tools and methodology utilized to build \emph{Scandal}. We start discussing how to produce sound in the Java Runtime Environment, and particularly how it deals with real-time audio. We next give a formal presentation on how the domain-specific language was designed, and attempt to classify it among other programming languages and music-DSL's. Finally, we address the methodology involved in building its compiler, appending to the latter a short discussion on how a general-user interface was designed to provide an integrated development environment experience for the end user, as well as alternative command-line methods for compiling and running \emph{Scandal} programs.

\section{How \emph{Scandal} Manages Sound}

The JRE System Library provides a very convenient package of classes that handle the recording and reproduction of real-time audio, namely the \il{javax.sound.sampled} package. In it, we find two classes, \il{TargetDataLine} and \il{SourceDataLine}, that deal respectively with capturing audio data from the system's resources, and playing back buffers of audio data owned by the application. An instance of \il{SourceDataLine} provides a \il{write} method that takes three arguments: an array of bytes to written to a \il{Mixer} object, an integer offset, and an integer length. In \emph{Scandal}, we do not specify a \il{Mixer} object, hence we make use of one provided by the \il{System}. There are two main aspects of the \il{write} method that need to be addressed. Firstly, it blocks the thread in which it lives until the given array of bytes has been written, from offset to length, to the \il{Mixer} its \il{SourceDataLine} contains; secondly, if nothing is done, it returns as it has no more data to write. In order to have real-time audio, one then needs to be constantly feeding this \il{write} method with audio samples, for as long as one wants continuous sound output, even if these buffers of audio samples contain only zeros, i.e., silence. It immediately follows that one must specify exactly how many samples are sent at a time, naturally with consequences to the system's performance. This parameter is commonly referred in the industry as the \emph{vector size}. The trade-off is measured in terms of latency: a large a vector size helps slower systems perform better, or can allow more complex processing, or even increase polyphony. Latency, however, is bad for any live application, including the generation of MIDI notes, and the recording of live sound from a microphone. A good, low-compromise vector size is usually set to 512 samples, and normally these sizes will be powers of two. In order to specify the preferred vector size, as well as many other environment settings, \emph{Scandal} refers to a static class named \il{Settings}, which contains a static property \il{Settings.vectorSize}.

The aforementioned two characteristics of the \il{write} method within a \il{SourceDataLine} are managed by \emph{Scandal} by the class \il{AudioFlow}. In order to prevent \il{write} from prematurely returning, an instance of \il{AudioFlow} contains a boolean property named \il{running}, which is set to \il{true} for as long as real-time audio is desired. The fact that \il{write} blocks its thread, however, is managed by any class that contains itself an instance of \il{AudioFlow} as a property. The latter are in \emph{Scandal} the implementors of the \il{RealTimePerformer} interface, which is a contract that contains four abstract methods: \il{startFlow}, \il{stopFlow}, \il{getVector}, and \il{processMasterEffects}. The role of the \il{startFlow} is to merely embed an \il{AudioFlow} within a new \il{Thread} object and start this new thread. This guarantees the thread that manages audio is different than the main \il{Application} thread, hence resolving the thread-blocking issue. Once a new \il{Thread} is started in \emph{Java}, however, one cannot in general interrupt it. In order to stop the audio thread, we set the property \il{running} inside an \il{AudioFlow} to false via the \il{stopFlow} method, which causes the \il{write} method inside the \il{AudioFlow} to return. Hence one cannot resume an audio process in \emph{Scandal} at this point, even though doing so is perfectly possible in \emph{Java}. The reason for that is not that of a design choice, but rather the fact that the domain-specific language is at its infancy, and many important features that go beyond a proof-of-concept are yet to be implemented. The \il{getBuffer} method is called by the \il{AudioFlow} every time it needs to write another vector of audio samples. It is the responsibility then of any \il{RealTimePerformer} to timely compute the next \il{Settings.vectorSize} samples of audio data. Finally, the \il{processMasterEffects} routine is called from within \il{getVector} to further process the buffer of audio samples. This is usually done while the samples are still represented as floats, hence before converting them to raw bytes.

The constructor of an \il{AudioFlow} takes, in addition to a reference to a \il{RealTimePerformer}, a reference to an \il{AudioFormat} object. The latter is part of the \il{javax.sound.sampled} package and is how we ask the \il{AudioSystem} for a \il{SourceDataLine}. Instead of constructing \il{AudioFormat} objects, however, the \il{Settings} class contains static members \il{Settings.mono} and \il{Settings.stereo} that are instances of \il{AudioFormat} defining a mono and stereo format, respectively. In addition to a channel count argument, \il{AudioFormat} instances are constructed by specifying a sampling rate, and a bit depth (word length) for audio samples. Those are, too, static properties in the \il{Settings} class, namely \il{Settings.samplingRate} and \il{Settings.bitDepth}. Listing \ref{alg:play} gives the specifics of maintaining a \il{SourceDataLine} open inside an instance of \il{AudioFlow}. The latter implements, in turn, the \il{Runnable} interface, hence needs to override a \il{run} method. Inside this \il{run} method, we call the private \il{play} subroutine that is given below:

\begin{lstlisting}[language=Java,caption={Writing buffers of audio data inside the \il{play} subroutine.},label={alg:play}]
private void play() throws Exception {
	SourceDataLine sourceDataLine = AudioSystem.getSourceDataLine(format);
	sourceDataLine.open(format, Settings.vectorSize * Settings.bitDepth / 8);
	sourceDataLine.start();
	while (running) {
		ByteBuffer buffer = performer.getVector();
		sourceDataLine.write(buffer.array(), 0, buffer.position());
	}
	sourceDataLine.stop();
	sourceDataLine.close();
}
\end{lstlisting}

Inside the \il{play} subroutine, we acquire a \il{SourceDataLine} object from the \il{AudioSystem} with the specific format that the \il{RealTimePerformer} passed while constructing this \il{AudioFlow}. In order to \il{open} the data line, we need specify a buffer size in bytes, hence we multiply the vector size by the word length in bits, divided by eight, as there are eight bits per byte. We then \il{start} the data line and keep writing to it for as long as the \il{RealTimePerformer} maintains the \il{running} property inside its \il{AudioFlow} set to true. At each call to \il{write}, we ask the performer for a new vector. Filling the vector causes its position to advance until its length, hence the \il{position} method inside the \il{ByteBuffer} class will in fact return the length value we desire. The rest of the \il{play} subroutine simply releases resources before returning, at which point the audio thread is destroyed.

\section{How \emph{Scandal} Handles MIDI}

\section{The Structure of the Compiler}

In a broad perspective, the compilation process of \emph{Scandal}'s DSL has the following steps:

\begin{enumerate}
	\item A path to a \emph{.scandal} file is passed as an argument to the constructor of the compiler and a linker subroutine is called, in order to resolve any dependencies;
	\item The code is passed through a scanner, which removes white space and comments while converting strings of characters to tokens. Any illegal symbol will cause the scanner to throw an error, interrupting the compilation process;
	\item The tokens are parsed and converted into an abstract syntax tree, during which many tokens are discarded. If the order of the tokes does not match any of the constructs that \emph{Scandal} understands, the parser throws an error and interrupts the compilation process;
	\item The root of the AST begins the process of \emph{decorating} the tree, in which name references are resolved, types are checked, and variable slot numbers are assigned, whenever applicable. To keep track of names, a LeBlanc-Cook symbol table is kept. If types do not match, or names cannot be referenced, the offending node in the AST throws an error, aborting the compilation;
	\item Again starting from the root of the AST, each node generates its corresponding bytecode, making use of the \il{org.objectweb.asm} library as a facilitator. For any node that is a subroutine, its body is added following its declaration. No errors are thrown in this phase, and the root node returns an array of bytes containing the program's instructions in \emph{Java} bytecode format;
	\item Every \emph{Scandal} program implements the \il{Runnable} interface. After the compiler receives the program's bytecode, it dynamically loads that bytecode as a \emph{Java} class on the current (main) thread, causing the \emph{Scandal} program to be executed.
\end{enumerate}

\subsection{The Linking Process}

The main entry point to the compilation process is given by the \il{Compiler} class, whose constructor requires a path to a \emph{.scandal} file. This class contains a \il{link} routine that is called before each compilation to resolve dependencies, and which is given in Listing \ref{alg:link} below. The \il{Compiler} class has a property named \il{imports}, which is an array of paths to other \emph{.scandal} files upon which the program at hand depends. It also holds a \il{path} property, which was passed to its constructor, and which is used as an argument to \il{link}'s first call. A \emph{Scandal} program may have at its outermost scope \il{import} statements, which take a single string as a parameter, which in turn represents a path to a \emph{.scandal} file in the file system. Any code contained in the file may depend on this imported path's content. Similarly, the imported path's content may depend itself on other imports, and so on, provided there is no circularity, that is, nothing imports something that depends on itself. We may regard then the linking process as a directed graph, in which arrows point toward dependencies. Since we do not allow cycles, this is a directed acyclic graph. It may very well be the case that more than one import depend on a particular file, in which case we certainly do not want to import that code twice. In order to import each dependency exactly once in an order that will satisfy every node of the DAG that points to it, we need to somehow sort the array of imports. It is easy to see that this is no different than the problem of donning garments, in which one must have her socks on before putting her shoes, and where some items may call for no particular order, such as a watch \cite[612]{Cormen2009}. The solution for this problem is to topologically sort the array of imports. Since it is a DAG, however, that is very easily accomplished by a depth-first search of the graph, which is exactly what Listing \ref{alg:link} accomplishes recursively.

\begin{lstlisting}[language=Java,caption={The linking process of a \emph{Scandal} program.},label={alg:link}]
private void link(String inPath) throws Exception {
	if (imports.contains(inPath)) return;
	Program program = getProgram(getCode(inPath));
	for (Node node : program.nodes)
		if (node instanceof ImportStatement)
			link(((ImportStatement) node).expression.firstToken.text);
	imports.add(inPath);
}
\end{lstlisting}

The if-statement in line 2 of the \il{link} routine deals with the base case of the recursion, namely the case in which we have already discovered that vertex. If we are seeing a vertex for the first time, line 3 converts the code into an AST, so we can check for any \il{import} statements therein. That is, in turn, accomplished by the for-loop in line 4, which checks each node in the AST's outermost scope for \il{import} statements. For each one it finds, line 6 recursively calls the \il{link} routine with the path extracted from that \il{import} statement. Since any code upon which we might depend needs to appear \emph{before} our own, the first vertex that is finished needs to go in front of the list, and so on. To be precise, this is a \emph{reverse} topological order. If the chain of imports given by the user contains a cycle, then no topological order exists, and the \emph{Scandal} program will throw a runtime error. This is not ideal, and future versions of \emph{Scandal} will throw a compilation error instead. In order to do so, however, more structure needs to be added to the compiler, so that we may check for backward edges in the linking process, although this feature remains unimplemented.

\subsection{The Scanning Process}

The design of the entire complier takes full advantage of \emph{Java}'s object-oriented paradigm. In order to convert strings of characters from the input file into tokens, we first define a particular \emph{type} of token for each individual construct in the DSL. This is accomplished by the \il{Token} class, which contains a static enumeration \il{Kind}, that in turn defines a type for each string of characters the DSL understands. The constructor of \il{Token} takes a \il{Token.Kind} as input, and each instance of \il{Token} contains, in addition, a \il{text} property, which holds the particular string of characters for that token's kind, as well as other properties that are convenient when throwing errors, namely that token's line number, position within the input array of characters, position within the line, and length. The \il{Token} class also contains methods for converting strings into numbers, as well as convenience methods for determining whether the kind of a particular instance of \il{Token} belongs to a particular \emph{family} of tokens, i.e., whether a token is an arithmetic operator, or whether it is a comparison operator, and so on.

What the \il{Scanner} class accomplishes is the conversion of an array of characters into an array of instances of \il{Token}. The mechanism is conceptually very simple: we scan the input array from left to right and, whenever we see a string of characters that matches one of the DSL's constructs, we instantiate a new \il{Token} and add it to the array of tokens we hold, in order. In the process, we skip any white space found. These can be tab characters, space characters, new lines, hence \emph{Scandal}, unlike \emph{Python} or \emph{Make}, makes no syntactical use of line breaks or indentation. The only role white spaces play in a \emph{Scandal} program is that of improved readability. \emph{Scandal} also supports two kinds of comments: single-line, which are preceded by two forward slashes, and multi-line, where a slash \emph{immediately} followed by a star character initiates the comment, and a start immediately followed by a slash terminates it. Unlike \emph{Java} or \emph{Swift}, comments are not processed as documentation, and are thus completely discarded. Their only purpose is to document the \emph{.scandal} file in which they are contained. String literals in \emph{Scandal} are declared by enclosing the text between quotes, and single apostrophe are neither allowed, nor in the language's alphabet anywhere. Besides token kinds that bear syntactical relevance, there is an additional \emph{end-of-file} kind that exists for convenience, and is placed at the end of the token array right before the \il{scan} method returns. Checking for illegal characters, or combinations thereof, such as a name that begins with a number, for example, is all the checking the \il{Scanner} class does. All syntactical checking is delegated to the parsing stage of compilation.

\subsection{The Parsing Process}

The main purpose of the parsing stage is to convert the concrete syntax of a \emph{Scandal} program into an abstract syntax tree, where constructs are hierarchically embedded in one another. An instance of the \il{Parser} class is constructed by passing a reference to a \il{Scanner} object. The process is unraveled by invoking the \il{parse} method, which returns an instance of the \il{Program} class. A \il{Program} is a subclass of \il{Node}, an abstract class that provides basic structure for every node in the AST. In particular, \il{Program} is the node that lies at the root of the AST. For each construct specified by the concrete syntax of \emph{Scandal}, there is a corresponding construct specified by its abstract syntax. More often than not, the abstract construct will be simpler, sometimes with many tokens removed. The job of the parser is to facilitate the process of inferring meaning from a given program, and it does so by going, from left to right, through the array of tokens passed by the scanner and, whenever it sees a sequence of tokens that matches one of the constructs in the concrete syntax, it consumes those tokens and creates a subclass of \il{Node} that corresponds to the construct at hand. It follows, for every acceptable construct in the DSL, there is a subclass of \il{Node} that defines it. Some nodes are nested hierarchically in others, and ultimately all nodes are nested in an instance of \il{Program}, hence why the parsing stage ultimately constructs a tree.

Structuring a program hierarchically is essential for inferring the meaning of complex expressions that have some sort of precedence relation among its sub-expressions. That is the case of arithmetic operations, in which, say, multiplication has precedence over addition, and exponentiation has precedence over multiplication. As an example, \emph{Supercollider} evaluates $3 + 3 * 3$ to $18$, since it parses the expression from left to right without regard for the precedence relations among arithmetic operators. This is counterintuitive, and does not correspond to how mathematical expressions are evaluated in general. We would like, instead, the expression $3 + 3 * 3$ to evaluate to $12$, in which case we cannot take it from left to right. Rather, we must first evaluate $e_2 = 3 * 3$, \emph{then} evaluate $e_1 = 3 + e_2$. It is easy to see that, no matter how complex the expression might be, we can always represent it as a \emph{binary} tree by taking the leftmost, highest-precedence operator and splitting the expression in half at that point. We then look at each sub-expression and do the same, until we reach a leaf. Note that the AST is not, in general, a binary tree. If two operators have the same precedence, we associate from left to right, that is, $1 - 2 + 3 = (1 - 2) + 3 = 2$, which also corresponds to how mathematical expressions associate. Complex expressions are dealt in \emph{Scandal} by the \il{BinaryExpression} class, and the fact that instances of \il{BinaryExpression} may contain other instances of \il{BinaryExpression} simply means we must construct them recursively. We shall discuss in detail each syntactical construct of \emph{Scandal} in the sections that follow, along with their concrete and abstract syntax definitions, and parsing routines.

% TODO: add graph of a binary tree

\subsection{Decorating the AST}

The idea of representing a program as a tree has many advantages, chief among them being the fact we can traverse the tree to infer its meaning. This is often non-trivial, and is necessary as many constructs are name-references to other constructs, and require that we look back to how they were originally declared if we are to make sense of them. In \emph{Scandal}, every subclass of \il{Node} overrides the abstract method \il{decorate}, which in turn takes an instance of \il{SymbolTable} as an argument. The latter is a class that implements a LeBlanc-Cook symbol table \cite{Cook1983}. Several nodes in the DSL define new naming scopes, \il{Program} being the node that holds the zeroth scope. These nodes are namely those that have \il{Block}, or its subclass \il{LambdaBlock} as members. \il{IfStatement} and \il{WhileStatement} both have \il{Block} as a child node, whereas \il{LambdaLitBlock} points to a \il{LambdaBlock}, who differs from \il{Block} in that it has a return statement. \il{LambdaBlock} only exist in the context of a lambda literal expression, however instances of \il{Block}, inside if or while-statements or on their own, may exits arbitrarily, always defining new naming scopes. Every time we enter a new scope in \emph{Scandal}, we have access to variables that were declared in outer scopes, but the converse is not true. Also, every time we enter a new scope, we have the opportunity of re-declaring variables' names without the risk of clashing with names already declared in outer scopes. For each scope, we hold a hash table whose keys are the variables' names, and whose values are subclasses of the abstract type \il{Declaration}. In order to \emph{remember} as we enter new scopes, and \emph{forget} as we leave them, an instance of \il{SymbolTable} holds a \il{Stack} of name-declaration hash tables, since stacks are exactly the kind of data structure that gives us this last-in, first-out behavior. In order to trigger the whole process of decorating the AST, the \il{Compiler} class instantiates a \il{SymbolTable}, and passes that as an argument to the instance of \il{Program} that was returned by the parser. Listing~\ref{alg:compile} shows how this is done in the \il{compile} method inside \il{Program}. Since every node overrides the \il{decorate} method, this instance of \il{SymbolTable} is passed down along the entire tree. Nodes that introduce new naming scopes have the responsibility of pushing a new hash table onto the stack, then popping it before returning from the \il{decorate} method.

In addition to resolving names, the decoration process is crucial for type-checking expressions and statements in the DSL. Even though the \emph{Java} bytecode instructions are explicitly typed, languages that compile to bytecode do not need to be. That is the case of \emph{Scala} and \emph{Groovy}, in which types can be inferred, or declared explicitly. Furthermore, there is a degree of latitude to which types can actually \emph{change} in the bytecode implementation. The JVM only cares that, once a variable is stored in a certain slot number as, say, a float, that is, using the instruction \il{FSTORE}, that it be retrieved too as a float, that is, using the instruction \il{FLOAD}. It is perfectly possible to use the same slot number to, say, \il{ISTORE} an integer value. The only consistency the JVM requires is that, for as long as that slot holds an integer, the value can only be retrieved by an \il{ILOAD} instruction. This requirement naturally extends to method signatures, which are also explicitly typed in the JVM. Hence, like \emph{JavaScript}, one can theoretically change the type of a variable attached to a name after it has been declared; unlike \emph{JavaScript}, however, types have to be assigned to arguments when declaring a method, and that method signature is immutable. It is still possible to overload a method to accept multiple signatures, but overloaded names are still \emph{different} methods, with altogether different bodies. The same applies to non-primitive types, that is, types that are instances of a class in the JVM. To store or retrieve non-primitive types, we use the \il{ASTORE} and \il{ALOAD} JVM instructions, respectively. Hence it is also theoretically possible to overwrite non-primitive types. However, method signatures that take non-primitives require a fully-qualified class name, hence are immutable as above. A fully-qualified name is the name of the class, preceded by the names of the packages in which it is contained, separated by forward slashes. For \il{Compiler}, for example, we have \il{language/compiler/Compiler}.

\begin{lstlisting}[language=Java,caption={Triggering the compilation process of a \emph{Scandal} program.},label={alg:compile}]
public void compile() throws Exception {
	imports.clear();
	code = "";
	link(path);
	for (String p : imports) code += getCode(p);
	symtab = new SymbolTable(className);
	program = getProgram(code);
	program.decorate(symtab);
	program.generate(null, symtab);
}
\end{lstlisting}

\emph{Scandal} is, by design choice, strongly typed. There are many reasons for that. The main reason is that the only kind of method it supports is that of a lambda expression, even though \emph{Scandal} is not a pure functional language. These lambda expressions define themselves their own parametrized sub-types, hence a lot of what the language \emph{is} hinges on type safety. It is also a design choice to make \emph{Scandal} accessible as an entry-level language, that is, directed toward an audience interested in learning audio signal processing in more depth, without the implementation hiding inherent to the unit-generator concept. Having types explicitly defined can help inexperienced programmers better debug their code, as well as help them understand the underlying implementation of the language. Type inference is, in essence, another way of hiding implementation, which has advantages, but also drawbacks. It is notoriously difficult to report errors and debug large projects in an IDE with languages that are not strongly typed. That is certainly the case with \emph{JavaScript}, of which \emph{TypeScript} is a typed superset aimed exactly at facilitating development within an IDE. \emph{Scandal} is fully integrate into its IDE, where reporting compilation errors to the programmer is a lot more informative, hence educational, than throwing runtime errors and aborting execution. For all these reasons, type-checking is one of the main jobs the decoration process accomplished. It can become rather involved, especially when it comes to composing partial applications of lambda expressions. We shall describe the intricacies of type checking alongside each of the DSL's constructs in the sections that follow.

\subsection{Generating Bytecode}

Similarly to the decoration process, bytecode generation is triggered from the root of the AST, that is, an instance of \il{Program} received from the parser, and which has been already decorated, and passed down to every node of the tree by a common abstract method each subclass of \il{Node} overrides. In this case, this common method is called \il{generate}, and it takes two arguments. The first is an instance of \il{org.objectweb.asm.MethodVisitor}, and the second is the the decorated instance of \il{SymbolTable}. \il{MethodVisitor} is part of the ASM library, which is a convenient set of tools aimed at facilitating the generation of \emph{Java} bytecode. As the name suggests, it visits a method within the bytecode class and adds statements to it. As can be seen in line 9 of Listing~\ref{alg:compile}, a null pointer is passed to the very first call to \il{generate}, since at that point we have not created any methods in the bytecode class yet. Every \emph{Scandal} program compiles to a \emph{Java} class, which in turn implements the \il{Runnable} interface. Inside the class, there are three methods: \il{init}, where we create the method bodies of lambda literal expressions, which are always fields in the \emph{Java} class; \il{run}, which is a required override of the \il{Runnable} interface, and where we create all \emph{Scandal} local variables and statements; and \il{main}, where we instantiate the class and call \il{run}. Inside \il{Program}, the \il{generate} method creates three instances of \il{MethodVisitor}, one for each aforementioned method.

If and only if a child node is an instance of \il{LambdaLitDeclaration}, a \il{Node} used to declare a name and assign to it a lambda literal expression, this child node is passed an instance of \il{MethodVisitor} that lives inside the \il{init} method. The immediate implication of this design choice is that lambda literal expressions are always global variables in a \emph{Scandal} program, thus accessible everywhere. However, they must be declared at the outermost scope of the program, and will throw a compilation error if declared elsewhere. A similar design pattern applies to nodes that are instances of \il{FieldDeclaration}, a \il{Node} used to declare field variables in the \emph{Java} class, which in turn correspond to global variables in the \emph{Scandal} program. For both \il{LambdaLitDeclaration} and \il{FieldDeclaration} nodes, we need to add field declarations in the \emph{Java} class, which is accomplished by instantiating, for each of these nodes, a \il{org.objectweb.asm.FieldVisitor}. This is only ever done inside \il{Program} hence, as a consequence, global variables in a \emph{Scandal} program must always be declared at the outermost scope. Similarly to instances of \il{LambdaLitDeclaration}, instances of \il{FieldDeclaration} in inner scopes throw a compilation error. Every descendant of the root node that is \emph{not} an instance of \il{LambdaLitDeclaration} receives as a parameter to its \il{generate} method an instance of \il{MethodVisitor} that lives inside the \il{run} method of the \emph{Java} class. This includes instances of \il{FieldDeclaration}, which are only declared by a \il{FieldVisitor}, and whose assignment is done inside the \il{run} method, along with all other declarations and statements.

Unlike instances of \il{FieldDeclaration}, instances of \il{LambdaLitDeclaration} are marked as \emph{final} in the \emph{Java} class, hence cannot be reassigned. The reason is simple: once reassigning a variable that points to a method body, the latter may become inaccessible. In \emph{Scandal}, one can create references to lambdas inside the \il{run} method, which are not instances of \il{LambdaLitDeclaration}, that is, which do not specify a method body. These references are rather instances of the superclass \il{AssignmentDeclaration}, and can be freely reassigned, even to lambdas that have different parameters, i.e., method signatures, that that of the original assignment. Reassigning references to lambdas come allow for great code re-usability. There is a third subclass of \il{Node} which can only be used at the outermost scope, namely \il{ImportStatement}. The reason is, besides clarity and organization of \emph{Scandal} code, because the \il{link} routine inside \il{Program} only looks for import statements within the outermost scope of a program's AST. In all three such nodes, checking whether that particular instance lives in the outermost scope is a simple matter of asking the passed instance of \il{SymbolTable} whether the current scope number is zero.

\subsection{Running a \emph{Scandal} Program}

Every \il{Program} node holds an array of bytes corresponding to a binary representation of the compiled \emph{Scandal} program. This array is created right before the \il{generate} method returns. The \il{Compliler} class naturally holds a reference to an instance of \il{Program}, and utilizes the latter's \il{bytecode} property to dynamically instantiate the \emph{Scandal} program as a \emph{Java} class, that is, from an array of bytes stored in memory, rather than from a \emph{.class} in the file system. Within the IDE, a path to a \emph{Scandal} program is used to instantiate a \il{Compiler}. After calling the \il{compile} method, the resulting bytecode is used to define a subclass of \il{java.lang.ClassLoader}, namely \il{DynamicClassLoader}, which is capable of dynamically instantiating a byte array as a \emph{Java} class, as opposed to the instance returned by the static method \il{ClassLoader.getSystemClassLoader()}, which can only load classes from the file system. Once defined, we construct and instantiate the program, finally casting the result to \il{Runnable}, as illustrated in Listing \ref{alg:instance}. The \il{getInstance} method is called from the IDE by the tab that currently holds the pogram's text editor, which is an instance of \il{ScandalTab}. After retrieving the instance of \il{Runnable}, the \il{ScandalTab} simply puts is on a new \il{Thread}. Starting the thread then causes the \emph{Scandal} program to execute.

\begin{lstlisting}[language=Java,caption={Obtaining an instance of a \emph{Scandal} program.},label={alg:instance}]
public Runnable getInstance() throws Exception {
	ClassLoader context = ClassLoader.getSystemClassLoader();
	DynamicClassLoader loader = new DynamicClassLoader(context);
	return (Runnable) loader
			.define(className, program.bytecode)
			.getConstructor()
			.newInstance();
}
\end{lstlisting}

\section{The Syntax of \emph{Scandal}}

In this section, we describe in detail every syntactical construct of \emph{Scandal}. For each of them, we state their concrete and abstract syntax definitions, how one is converted into the other in the parser, as well as the particularities of type-checking and generating bytecode. We omit some constructs that, either have trivial implementations, or whose implementations are, \emph{mutatis mutandis}, identical to other constructs, in which case we describe only a representative. In the discussion that follows, terminal symbols are in all-capital letters, productions in the concrete syntax begin with a lower-case letter, and their counterparts in the abstract syntax begins with an upper-case letter. We here present terminal symbols in the syntactical context in which they appear, and a complete list of terminal symbols can be found in Sec.~\ref{sec:symbols}.

\subsection{Top-Level Productions}

At the topmost level of a \emph{Scandal} program, there are basically only two kinds of constructs that are allowed, namely declarations and statements. The legal declarations at this level are further subdivided into three: assignment declarations, field declarations, and lambda literal declarations. In the productions that follow, the star symbol represents a \emph{Kleene} star, and or-symbols and parenthesis are not tokens in the language. As a rule, terminal symbols will be given by their names, like \texttt{OR}, to avoid confusion with symbols in the language's grammar. Below are the production rules for \il{program}:

\begin{itemize}
	\item type := \texttt{KW\_INT} $|$ \texttt{KW\_FLOAT} $|$ \texttt{KW\_BOOL} $|$ \texttt{KW\_STRING} $|$ \texttt{KW\_ARRAY} $|$ \texttt{KW\_LAMBDA}
	\item declaration := assignmentDec $|$ fieldDec $|$ lambdaLitDec $|$ paramDec
	\item program := (assignmentDec $|$ fieldDec $|$ lambdaLitDec $|$ statement)$^*$
\end{itemize}

In the AST, \il{Declaration} is an abstract class that has two subclasses: \il{AssignmentDeclaration}, and \il{ParamDeclaration}. The former has two subclasses, \il{FieldDeclaration}, and \il{LambdaLitDeclaration}. The primary difference between the two subclasses of \il{Declaration} is that the latter defines a type and a name without binding any value to that name at the time of declaration, while the former requires that some expression be given at the moment the variable is declared. It follows every variable declaration in \emph{Scandal} must be initialized, except when they are parameters of a lambda literal, in which case they actually cannot be initialized. A \il{program} can contain any number of \il{assignmentDec}, \il{fieldDec}, or \il{lambdaLitDec}, in any order, while a \il{paramDec} only exist in the context of a lambda literal. As will be seen below, every \il{declaration} begins with a type token, or with a \il{field} flag, followed by a type token. The abstract syntax of \il{Program} is then:

\begin{itemize}
	\item Declaration := AssignmentDeclaration $|$ FieldDeclaration
	\item Declaration := LambdaLitDeclaration $|$ ParamDeclaration
	\item Program := (AssignmentDeclaration $|$ FieldDeclaration)$^*$
	\item Program := (LambdaLitDeclaration $|$ Statement)$^*$
\end{itemize}

The parsing routine for \il{program} is very simple, and constructs an instance of \il{Program} by checking whether the next token in the array of tokens produced by the scanner is in the FIRST set of \il{declaration}. If it is, we attempt to construct an instance or subclass of \il{AssignmentDeclaration}, consuming in the process all the tokens therein. If not, we attempt to construct a subclass of the abstract type \il{Statement}. That is done much that same way, by looking at the set FIRST(\il{statement}). Listing \ref{alg:program} shows how a concrete \il{program} is converted into a \il{Program} node in the AST.

\begin{lstlisting}[language=Java,caption={Parsing topmost-level constructs in \emph{Scandal}.},label={alg:program}]
public Program parse() throws Exception {
	Token firstToken = token;
	ArrayList<Node> nodes = new ArrayList<>();
	while (token.kind != EOF) {
		if (token.isDeclaration()) nodes.add(assignmentDeclaration());
		else nodes.add(statement());
	}
	matchEOF();
	return new Program(firstToken, nodes);
}
\end{lstlisting}

In Listing \ref{alg:program}, we construct an instance of \il{Program} by first creating an array of nodes. These nodes, however, must be either a subclass of \il{AssignmentDeclaration}, or a subclass of the abstract class \il{Statement}. Line 5 checks whether the next unconsumed token is in the FIRST set of a declaration. If so, further parsing is delegated to the \il{assignmentDeclaration} routine. If not, the only other option is that the next token initiates a statement, and parsing thereof is delegated to the \il{statement} routine in line 6. Nodes are added in the exact order in which they appear in the \emph{Scandal} program, regardless whether they are declarations or statements. An end-of-file token was included in the scanning process for convenience, and here we make use of it by checking the next available token against the \texttt{EOF} kind. As soon as we find it, we know we have reached the end of the token array, and can thus stop looking for declarations and statements. If we were expecting a particular token, but \texttt{EOF} appeared prematurely, we throw an error.

Inside an instance of \il{Program}, type-checking is completely delegated to each node in the node array. More precisely, inside the \il{decorate} routine, we iterate over the node array and, for each node, we call \il{node.decorate}, passing along the symbol table instantiated by the compiler. Generating bytecode, on the other hand, is a lot more complex, since we need to provide the overall structure for the entire \emph{Java} class. That is accomplished inside the \il{generate} method by creating an instance of \il{org.objectweb.asm.ClassWriter}. The latter, which we call \il{cw}, manages the creation of the \emph{Java} class itself, including the generation of the byte array used to instantiate and run the \emph{Scandal} program. In particular, we set the JRE to version 1.8, make the access to the class \il{public}, and define it as a subclass of \il{java/lang/Object} that implements the \il{java/lang/Runnable} interface. We then create three instances of \il{MethodVisitor} by calling \il{cw.visitMethod}, one for each method in the \emph{Java} class. The methods are namely \il{init}, \il{run}, and \il{main}. In \il{init}, we basically go through the node array and, if the particular node is an instance of \il{LambdaLitDeclaration}, we call \il{node.generate}, passing the appropriate instance of \il{MethodVisitor} and our symbol table as parameters. What the \il{generate} method does inside a \il{LambdaLitDeclaration} is somewhat complicated, and we defer its explanation to the moment we discuss the \il{LambdaLitExpression} class. Before visiting \il{run}, we go once again over all nodes in the node array and, if they are either an instance of \il{LambdaLitDeclaration} or an instance of \il{FieldDeclaration}, we call \il{cw.visitField}. This method creates fields in the \emhp{Java} class, which correspond to \il{field} variables in the \emph{Scandal} program. Every field is marked as \il{static}, since we make no use of \emph{Java}'s object-oriented paradigm. In addition, lambda fields are marked as \il{final}, as previously discussed, and we take the opportunity to pass \il{cw} along to the instances of \il{LambdaLitExpression} for which we are creating field declarations, and ask them to create a method body for the lambda literal expression. This is accomplished inside each lambda literal expression by an overloaded \il{generate} method, which takes, instead of a \il{MethodWriter}, the instance of \il{ClassWriter}, namely \il{cw}, and uses that to create its own \il{MethodWriter}, which will correspond to the lambda's method. The instances of \il{LambdaLitExpression} are accessed through the \il{lambda} property inside the \il{LambdaLitDeclaration}, and the particularities of creating method bodies for lambdas will be discussed momentarily. The next step is to add a body for the \emph{Java} class' \il{run} method. To do so, we go yet once more over the array of nodes, and this time we generate any node that is \emph{not} an instance of \il{LambdaLitDeclaration}, for obvious reasons. We do visit instances of \il{FieldDeclaration}, since \il{cw.visitField} only created the field, but never assigned any value to it. Since we only allow unassigned declarations in \emph{Scandal} when declaring lambda parameters, we have something to assign to that field, and \il{generate} inside \il{FieldDeclaration} takes care of that.

\begin{lstlisting}[language=Java,caption={Using the ASM framework to construct a \il{main} method.},label={alg:main}]
private void addMain(ClassWriter cw, SymbolTable symtab) {
	MethodVisitor mv =
		cw.visitMethod(ACC_PUBLIC + ACC_STATIC, "main", "([Ljava/lang/String;)V", null, null);
	mv.visitTypeInsn(NEW, symtab.className);
	mv.visitInsn(DUP);
	mv.visitMethodInsn(INVOKESPECIAL, symtab.className, "<init>", "()V", false);
	mv.visitMethodInsn(INVOKEVIRTUAL, symtab.className, "run", "()V", false);
	mv.visitInsn(RETURN);
	mv.visitMaxs(0, 0);
}
\end{lstlisting}

Finally, we visit the \il{main} method in the \emph{Java} class, which is shown in Listing \ref{alg:main}. This is the standard \il{main} method in \emph{Java}, which is always \il{public} and \il{static}, takes an array of strings, and returns nothing. Line 3 uses \il{cw} to create an instance of \il{MethodVisitor}, namely \il{mv}, with exactly these properties. Bytecode syntax for method signatures is given by a parenthesized list of argument types, followed by the return type. Hence a \il{void} method that takes a \il{String[]} in \emph{Java} becomes \il{([Ljava/lang/String;)V}, where the left bracket means we have an array of whatever type follows, and the colon separates argument types. Naturally, \il{java/lang/String} is a string, and \il{V} stands for the \il{void} type. The JVM is stack-based, so in line 4 we create a new instance of the \emph{Java} class, whose name is stored in our symbol table, and leave it on top of the stack. In line 5 we duplicate whatever is on top of the stack, since we will need to use our newly created \emph{Java} class twice, namely to call on it \il{init}, and then \il{run}. These two calls are made in lines 6 and 7, respectively. Notice both method signatures take no arguments and return nothing, hence are equivalent to \il{()V} in bytecode. Finally, we add a return statement to the \il{main} method's body, which is omitted in \il{void} \emph{Java} methods, but required in bytecode. A bytecode method requires that we compute the maximum number of elements the stack will have, as well as the total number of local variables in the method. ASM does that for us, and we asked it to do so by passing a \il{ClassWriter.COMPUTE_FRAMES} as an argument while constructing \il{cw}. The two arguments to \il{mv.visitMaxs} are the maximum stack size, and the total local variables. We pass zeros since we are not computing them, but the call must be made nonetheless.

\subsection{Subclasses of \il{Declaration}}

The class \il{Declaration} is an abstract type that extends \il{Node} by adding three instance variables, namely a \il{Token} to hold the name we are declaring, an integer to hold its slot number, and a boolean property to distinguish whether this is a field or not. Slot numbers are not necessary for fields, hence are only used in the context of the \emph{Java} class' \il{run} method. \il{Declaration} branches out into two non-abstract subclasses, \il{ParamDeclaration} and \il{AssignmentDeclaration}. The latter has itself two other subclasses, \il{FieldDeclaration} and \il{LambdaLitDeclaration}. As discussed above, the difference is that \il{ParamDeclaration} only occurs inside a \il{LambdaLitDeclaration}; \il{FieldDeclaration} and \il{LambdaLitDeclaration} only occur at the outermost scope; and \il{AssignmentDeclaration} occurs anywhere. Below are the production rules for the concrete syntax of declarations in \emph{Scandal}.

\begin{itemize}
	\item paramDeclaration := type \texttt{IDENT}
	\item assignmentDeclaration := type \texttt{IDENT} \texttt{ASSIGN} expression
	\item fieldDeclaration := \texttt{KW\_FIELD} assignmentDeclaration
	\item lambdaAssignment := \texttt{KW\_LAMBDA} \texttt{IDENT} \texttt{ASSIGN} (paramDeclaration)$^*$
	\item lambdaLitDeclaration := lambdaAssignment lambdaLit
	\item lambdaLitDeclaration := lambdaAssignment lambdaBlock
\end{itemize}

\begin{lstlisting}[language=Java,caption={Parsing Top-Level Declarations.},label={alg:assign}]
public AssignmentDeclaration assignmentDeclaration() throws Exception {
	boolean isField = token.kind == KW_FIELD;
	if (isField) consume();
	Token firstToken = consume();
	Token identToken = match(IDENT);
	match(ASSIGN);
	Expression e = expression();
	if (e instanceof LambdaLitExpression)
		return new LambdaLitDeclaration(firstToken, identToken, (LambdaLitExpression) e);
	if (isField) return new FieldDeclaration(firstToken, identToken, e);
	return new AssignmentDeclaration(firstToken, identToken, e);
}
\end{lstlisting}

As shown in line 5 of Listing \ref{alg:program}, we parse declarations by looking at the very first token at hand. In particular, we have FIRST(\il{declaration}) = \il{type} $\cup$ \texttt{KW\_FIELD}. Observing that \il{FieldDeclaration} is the only subclass of \il{Declaration} that may make use of a \il{field} flag, we can begin parsing declarations by first checking whether the first token of a declaration is indeed a \il{field} flag, setting a local boolean property accordingly, and consuming the \texttt{KW\_FIELD} token, as shown in line 2 of Listing \ref{alg:assign}. We then store the type and identifier tokens, consume the equals sign and delegate the expression rule to the \il{expression} routine. Based on which type of expression we receive, we create the corresponding subclass of \il{AssignmentDeclaration}. Even though lambda literal declarations are always fields in the \emph{Java} class, the \il{field} flag is not necessary, but \emph{can} be used without errors, since all that determines an instance of \il{LambdaLitDeclaration} is that the expression it contains is a subclass of \il{LambdaLitExpression}. Unassigned declarations, on the other hand, will fail the \il{match(ASSIGN)} call in line 6, and will cause a compilation error.

\subsubsection{The \il{ParamDeclaration} Class}

\il{ParamDeclaration} is basically an unchanged implementation of the abstract type \il{Declaration}. It adds no new properties, thus consisting of basically a type \il{Token} and an identifier \il{Token}. Since it is not abstract, it must override \il{decorate} and \il{generate}, the two abstract methods in \il{Node} that provide functionality to all nodes in the AST. Parsing a parameter declaration is absolutely straightforward, and done in the context of a \il{LambdaLitExpression}. We simply store and consume the type and identifier tokens, then use those to instantiate a \il{ParameterDeclaration}.

When a lambda literal expression is decorated, a new scope in the symbol table is introduced, so that parameter names do not clash with local variables in the \emph{Java} class' \il{run} method. Thus inside an instance of \il{ParamDeclaration}, the \il{decorate} method checks only the symbol table at the top of the stack of symbol tables to see whether any two parameters have the same identifier, in which case it throws a compilation error. If not, it inserts the identifier into the topmost scope of the symbol table, associating to the identifier the instance of \il{Declaration} at hand. Since parameter declarations are local variables inside a lambda body, they need to have the \il{slotNumber} property set so they can be accessed. This is accomplished, however, by the lambda literal expression class before the \il{decorate} method is called on a parameter declaration, as we shall see momentarily. In the \il{generate} method, we do nothing, since there is no value we can bind to the declaration's identifier at the moment. Naturally, these values will exist in the context of a lambda application.

\subsubsection{The \il{LambdaLitDeclaration} Class}

The \il{LambdaLitDeclaration} class is a particular case of \il{AssignmentDeclaration} where the expression is of type \il{LambdaLitExpression}. By defining a new type, we are able to separate more easily instances of lambda literals from other nodes inside a \il{Program}, as previously seen. As we shall see, having a specific type for lambda declarations is also invaluable when the underlying implementation of a lambda is obscured by partial applications and compositions, in which case we need to unravel an entire chain of bindings until we find a name that is bound to an expression of type \il{LambdaLitDeclaration}. We construct a lambda literal declaration by taking a \il{LambdaLitExpression}, and passing it to the constructor of the superclass. It follows the superclass' \il{expression} property is just a reference to this lambda literal expression property, which we call \il{lambda}. Naturally, every \il{LambdaLiteralExpression} inherits from \il{Expression}. At the time we construct a lambda literal declaration, we immediately set the \il{isField} boolean property to true, as discussed above.

Lambda literal declarations have very different implementations of the \il{Node} abstract methods than those of \il{AssignmentDeclaration}, hence both \il{decorate} and \il{generate} are overridden. The bodies of these methods are substantially simpler than the superclass' implementation, given the restricted nature of this type. Inside \il{decorate}, we check the entire stack of symbol tables to see whether we are not being redeclared, in which case an error is thrown. Checking only the topmost scope symbol table would work exactly the same, since lambda literal declarations are only allowed at the outermost scope, hence the stack only contain a single symbol table when we call \il{decorate}. If we are being declared for the first time, then we insert the identifier into the symbol table, associating to it the instance of \il{LambdaLitDeclaration} we have. Unlike parameter declarations, we now have an expression to decorate, which we do by calling \il{lambda.decorate}, hence delegating decoration to the \il{LambdaLitExpression} instance. Similarly, the \il{generate} method calls \il{lambda.generate}, which causes a lambda literal expression to be left on top of the JVM stack. We then bind this expression to the \il{identToken.text} property and return.

\subsubsection{The \il{FieldDeclaration} Class}

Field declarations are possibly the simplest type of declaration. They mostly exist for convenience, in order not to clutter its superclass \il{AssignmentDeclaration}, which has a somewhat more involved implementation. We construct them by calling the superclass' constructor with exactly the same arguments, but in addition we set the \il{isField} boolean property to true. We also override both \il{decorate} and \il{generate}. In the former, and similarly to \il{LambdaLitDeclaration}, we check all symbol table scopes to see if we are not being redeclared. Naturally, there is only ever one scope to check. If all is fine, we insert ourselves into the symbol table with a key given by \il{identToken.text} and a value of \il{this}. We then call \il{expression.decorate}, after which the expression will be decorated with a non-null \il{type}, a property that is common to every node. Unlike \il{LambdaLitDeclaration}, in which the declaration and lambda always had the same type by construction, here we can have runtime errors if the program tries to store, say, a float into an integer slot. We then simply check whether the expression's type is the same as the declaration's. The latter never needed to be decorated, and was set when the constructor of \il{Node} was called, since it could be inferred from the declaration's first token alone. The overridden \il{generate} method is identical to that of \il{LambdaLitDeclaration}.

\subsubsection{The \il{AssignmentDeclaration} Class}

Assignment declarations are the most general an common type of declaration in \emph{Scandal}. They correspond to all variable declarations that are not \emph{special}, neither in the sense of declaring a method body, nor in the sense of being global to a \emph{Scandal} program. In other words, they live inside the \emhp{Java} class' \il{run} method, as well as inside a lambda's body. Since the \il{isField} property is false by default, we construct a \il{AssignmentDeclaration} by passing a type token and an identifier token to the superclass, then storing our own \il{expression} property, the latter being what differentiates us from the abstract type \il{Declaration}. The decoration process is similar to those of the two subclasses of \il{AssignmentDeclaration}, but a bit trickier. We start by checking the top of the stack of symbol tables to see if there is no name clash, then insert into the symbol table a key of \il{identToken.text} with value \il{this}. We then assign a slot number to this variable, which we do by maintaining a property \il{slotCount} inside \il{SymbolTable}. We assign our slot number to the current slot count, then increase the latter. We call \il{expression.decorate}, similarly to what we do in field and lambda literal declarations, to decorate the expression, which will cause it to have a non-null type in most cases, except when the expression is an instance of \il{LambdaAppExpression}, in which case we hit a small roadblock in the type-checking process. To understand the situation, we provide in Listing \ref{alg:infer} a small snippet of \emph{Scandal} code.

\begin{lstlisting}[emph={lambda,float,return},emphstyle={\textbf},caption={Type inference in \emph{Scandal}.},label={alg:infer}]
lambda id = float x -> x
lambda higherOrder = float x -> lambda f -> {
	float val = f(x)
	return val
}
\end{lstlisting}

When a lambda expression in \emph{Scandal} has a parameter of type \il{lambda}, we have no mechanism in the language to tell what parameter types pertain to said lambda. The corresponding construction in \emph{Java} is an instance of the \il{Function} interface, which is a parameterized type. A lambda expression in \emph{Java} that takes a float and returns a float has type \il{Function<Float, Float>}, for example. It has been a design choice so far in \emph{Scandal} not to introduce parameterized types, and attempt instead at some yet crude type inference mechanism. It is a long-term goal to actually make \emph{all} types inferred. In Listing \ref{alg:infer}, we have an instance of \il{ParamDeclaration} that defines a variable \il{f} of type \il{lambda}. Inside the block, the mechanism of choice to in fact \emph{declare} what parameter types \il{f} has is through an assignment declaration. In line 3, we apply \il{x} to \il{f} and store the result in \il{val}. Since both \il{x} and \il{val} have type \il{float}, we are now at a position to determine with that \il{f} takes a single argument of type \il{float}, and returns also a float. Note that omitting line 3 and putting \il{return f(x)} instead would cause a compilation error, exactly because we cannot infer parameter types of a lambda expression inside a lambda literal if there is no application thereof.

Given the discussion above, whenever an assignment declaration calls \il{expression.decorate}, and this expression happens to be a lambda application inside a lambda literal, instead of expecting the call to \il{expression.decorate} to define a type for the expression, we actually decorate the expression ourselves. The process is very simple: after calling \il{expression.decorate}, we check if the expression is an instance of \il{LambdaAppExpression}. If so, we look for the declaration of that application's expression. If the declaration is an instance of \il{ParamDec}, we know our expression is an application of a lambda is a parameter of lambda literal expression, since parameter declarations only ever exist in this context. We then trust the programmer will make use of the lambda literal expression correctly, by applying to it a lambda expression that has the same parameter types as those inferred inside the block. If not, a runtime error will occur. This is obviously not a complete implementation and, as discussed previously, future versions of \emph{Scandal} will throw a compilation error instead. Finally, the \il{expression} property will have to have a type, which we check against the declaration type. Naturally, in the special case we decorate the expression ourselves, this test never fails. If it does, we throw a compilation error. Overriding the \il{generate} method inside an assignment declaration is straightforward. We make a call to \il{expression.generate}, which causes the expression value to be left on top of the JVM stack, after which we switch over the expression type, using the appropriate JVM instruction to store the variable.

\subsection{Subclasses of \il{Statement}}