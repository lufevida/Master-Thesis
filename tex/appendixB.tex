\chapter{}

\section{List of Terminal Symbols}
\label{sec:symbols}

\subsubsection{Binary Expressions}

\begin{itemize}
	\item expression := term (comparison term)$^*$
	\item comparison := \texttt{LT} $|$ \texttt{LE} $|$ \texttt{GT} $|$ \texttt{GE} $|$ \texttt{EQUAL} $|$ \texttt{NOTEQUAL}
	\item term := summand (summandOp summand)$^*$
	\item summandOp := \texttt{PLUS} $|$ \texttt{MINUS} $|$ \texttt{OR}
	\item summand := factor (factorOp factor)$^*$
	\item factorOp := \texttt{TIMES} $|$ \texttt{DIV} $|$ \texttt{MOD} $|$ \texttt{AND}
	\item factor := parethesizedExpression $|$ unaryExpression $|$ identExpression
	\item parethesizedExpression := \texttt{LPAREN} expression \texttt{RPAREN}
	\item unaryExpression := (\texttt{KW\_MINUS} $|$ \texttt{KW\_NOT}) expression
	\item identExpression := \texttt{IDENT}
\end{itemize}

\subsubsection{Literal Expressions}

Literal expressions are the simplest constructs in the language, and have the following concrete rules:

\begin{itemize}
	\item factor := intLitExpression $|$ floatLitExpression
	\item factor := boolLitExpression $|$ stringLitExpression
	\item intLitExpression := \texttt{INT\_LIT}
	\item floatLitExpression := \texttt{FLOAT\_LIT}
	\item boolLitExpression := \texttt{KW\_TRUE} $|$ \texttt{KW\_FALSE}
	\item stringLitExpression := \texttt{STRING\_LIT}
\end{itemize}

In the productions above, we note that non-zero integer literals are not allowed to start with a zero. In such a scenario, even though the scanner will create two tokes, one for zero, and another for the rest of the number, since there are no productions in the language that take two integers separated by white space, the parser inevitably will throw a compilation error. The same applies to floating-point decimals, where only one zero can come before the dot. I this particular case, a zero actually \emph{must} precede the \texttt{DOT} token, and such constructs as $x = .5$ are not allowed. Doubles, shorts, or longs do not exist in \emph{Scandal} as of yet, and there is no need to declare float literals the way they are in \emph{Java}, with $1.1f$ for float and $1.1$ for double, say. In fact, that will throw an error. As previously mentioned, string literals are constructed by enclosing text within quotes, and the use of apostrophes will cause a scanning error. Even though quotes are in the language's alphabet, they are never converted into a \il{Token}, as their only possible use is within a string literal. \texttt{DOT}, on the other hand, has uses besides separating the decimal part of a \texttt{FLOAT\_LIT}, namely in composed lambdas. Hence the scanner simply instantiates a token and delegates the inferring of meaning to the parser. Boolean literals are quite self-explanatory, and unlike \emph{C}, numbers are not allowed to replace booleans.

\subsubsection{Array Expressions}

\begin{itemize}
	\item factor := arrayLitExpression $|$ arrayItemExpression
	\item factor := arraySizeExpression $|$ newArrayExpression
	\item arrayLitExpression := \texttt{LBRACKET} expression (\texttt{COMMA} expression)$^*$ \texttt{RBRACKET}
	\item arrayItemExpression := identExpression \texttt{LBRACKET} expression \texttt{RBRACKET}
	\item arraySizeExpression := \texttt{KW\_SIZE} \texttt{LPAREN} expression \texttt{RPAREN}
	\item newArrayExpression := \texttt{KW\_NEW} \texttt{LPAREN} expression \texttt{RPAREN}
\end{itemize}

\subsubsection{Framework Expressions}

\begin{itemize}
	\item factor := piExpression $|$ cosExpression $|$ powExpression
	\item factor := floorExpression $|$ readExpression $|$ recordExpression
	\item piExpression := \texttt{KW\_PI}
	\item cosExpression := \texttt{KW\_COS} \texttt{LPAREN} expression \texttt{RPAREN}
	\item powExpression := \texttt{KW\_POW} \texttt{LPAREN} expression \texttt{RPAREN}
	\item floorExpression := \texttt{KW\_FLOOR} \texttt{LPAREN} expression \texttt{RPAREN}
	\item readExpression := \texttt{KW\_READ} \texttt{LPAREN} expression \texttt{COMMA} expression \texttt{RPAREN}
	\item recordExpression := \texttt{KW\_RECORD} \texttt{LPAREN} expression \texttt{RPAREN}
\end{itemize}

\subsubsection{Lambda Expressions}

\begin{itemize}
	\item factor := lambdaApp $|$ lambdaComp $|$ lambdaLit $|$ lambdaBlock
	\item lambdaApp := identExpression \texttt{LPAREN} expression (\texttt{COMMA} expression)$^*$ \texttt{RPAREN}
	\item lambdaComp := identExpression (\texttt{DOT} expression)$^*$
	\item lambdaComp := identExpression (\texttt{DOT} expression)$^*$ \texttt{DOT} lambdaApp
	\item lambdaLit := paramDeclaration \texttt{ARROW} (paramDeclaration \texttt{ARROW})$^*$ expression
	\item lambdaBlock := paramDeclaration \texttt{ARROW} (paramDeclaration \texttt{ARROW})$^*$ retBlock
	\item paramDeclaration := type \texttt{IDENT}
	\item retBlock := \texttt{LBRACE} (assignmentDeclaration $|$ statement)$^*$ retExpression \texttt{RBRACE}
	\item retExpression := \texttt{KW\_RETURN} expression
\end{itemize}

\subsubsection{Statements}

The latter set is, similarly to the \il{declaration} rule, the union of all keywords in the language, seen as tokens, that define a valid statement.

\begin{itemize}
	\item statement := assignmentStatement $|$ ifStatement $|$ whileStatement
	\item statement := printStat $|$ plotStat $|$ playStat $|$ writeStat
	\item assignmentStatement := \texttt{IDENT} \texttt{ASSIGN} expression
	\item ifStatement := \texttt{KW\_IF} expression block
	\item whileStatement := \texttt{KW\_WHILE} expression block
	\item block := \texttt{LBRACE} (assignmentDeclaration $|$ statement)$^*$ \texttt{RBRACE}
	\item printStat := \texttt{KW\_PRINT} \texttt{LPAREN} expression \texttt{RPAREN}
	\item plotStat := \texttt{KW\_PLOT} \texttt{LPAREN} expression \texttt{COMMA} expression \texttt{COMMA} expression \texttt{RPAREN}
	\item playStat := \texttt{KW\_PLAY} \texttt{LPAREN} expression \texttt{COMMA} expression \texttt{RPAREN}
	\item writeStat := \texttt{KW\_WRITE} \texttt{LPAREN} expression \texttt{COMMA} expression \texttt{COMMA} expression \texttt{RPAREN}
\end{itemize}

\subsection{The Abstract Syntax}

\begin{itemize}
	\item AssignmentDeclaration := Type \texttt{IDENT} Expression
	\item FieldDeclaration := Type \texttt{IDENT} Expression
	\item LambdaLitDeclaration := Type \texttt{IDENT} LambdaLitExpression
	\item LambdaLitDeclaration := Type \texttt{IDENT} LambdaLitBlock
	\item Type := \texttt{INT} $|$ \texttt{FLOAT} $|$ \texttt{BOOL} $|$ \texttt{STRING} $|$ \texttt{ARRAY} $|$ \texttt{LAMBDA}

	\item Expression := BinaryExpression $|$ IdentExpression $|$ LiteralExpression
	\item Expression := ArrayExpression $|$ UnaryExpression $|$ FrameworkExpression
	\item Expression := LambdaExpression
	\item BinaryExpression := Expression_0 (termOperator $|$ summandOperator $|$ factorOperator) Expression_1
	\item ReadExpression := Expression_0 Expression_1
	\item LambdaApp := IdentExpression Expression
	\item LambdaComp := IdentExpression^+ LambdaApp
	\item LambdaLit := ParamDeclaration$^+$ Expression
	\item LambdaBlock := ParamDeclaration$^+$ ReturnExpression
	\item ParamDeclaration := Type IDENT
	
	\item Statement := AssignmentStatement $|$ IfStatement $|$ WhileStatement
	\item Statement := PrintStatement $|$ PlotStatement $|$ PlayStatement $|$ WriteStatement
	\item AssignmentStatement := \texttt{IDENT} Expression
	\item IfStatement := Expression Block
	\item WhileStatement := Expression Block
	\item Block := (AssignmentDeclaration $|$ Statement)$^*$
	\item PrintStatement := Expression
	\item PlotStatement := Expression_0 Expression_1 Expression_2
	\item PlayStatement := Expression_0 Expression_1
	\item WriteStatement := Expression_0 Expression_1 Expression_2
\end{itemize}

\section{Type-Checker Rules}

\begin{itemize}
	\item UnassignedDeclaration:
		\subitem Variable may not be declared more than once in the same scope
	\item AssignmentDeclaration:
		\subitem Variable may not be declared more than once in the same scope
		\subitem Type = Expression.type
	\item AssignmentStatement:
		\subitem Variable must have been declared in some enclosing scope
		\subitem Declaration.Type = Expression.type
	\item IfStatement:
		\subitem Expression.type = BOOL
	\item WhileStatement:
		\subitem Expression.type = BOOL
	\item PrintStatement:
		\subitem Expression.type != ARRAY $|$ FORMAT $|$ FILTER $|$ WAVEFORM
	\item PlotStatement:
		\subitem Expression_0.type = STRING
		\subitem Expression_1.type = ARRAY
		\subitem Expression_2.type = INT $|$ FLOAT
	\item PlayStatement:
		\subitem Expression_0.type = ARRAY
		\subitem Expression_1.type = FORMAT
	\item WriteStatement:
		\subitem Expression_0.type = ARRAY
		\subitem Expression_1.type = STRING
		\subitem Expression_2.type = FORMAT
	\item UnaryExpression:
		\subitem Type = Expression.type
		\subitem Expression.type = INT $|$ FLOAT $|$ BOOL
	\item BinaryExpression:
		\subitem (INT $|$ FLOAT) (MOD $|$ PLUS $|$ MINUS $|$ TIMES $|$ DIV) (FLOAT $|$ INT) ==> FLOAT
		\subitem INT (summandOperator $|$ factorOperator) INT ==> INT
		\subitem (INT $|$ BOOL) (AND $|$ OR) (BOOL $|$ INT) ==> BOOL
		\subitem !(ARRAY $|$ STRING) termOperator !(STRING $|$ ARRAY) ==> BOOL
	\item IdentExpression:
		\subitem Variable must have been declared in some enclosing scope
		\subitem Type = Declaration.type
	\item IntLitExpression:
		\subitem Type = INT
	\item FloatLitExpression:
		\subitem Type = FLOAT
	\item BoolLitExpression:
		\subitem Type = BOOL
	\item StringLitExpression:
		\subitem Type = STRING
	\item ArrayLitExpression:
		\subitem Type = ARRAY
	\item InfoExpression:
		\subitem Type = STRING
	\item FormatExpression:
		\subitem Type = FORMAT
	\item WaveformExpression:
		\subitem Type = WAVEFORM
	\item FilterExpression:
		\subitem Type = FILTER
	\item ReadExpression:
		\subitem Type = ARRAY
		\subitem Expression_0.type = STRING
		\subitem Expression_1.type = FORMAT
	\item PanExpression:
		\subitem Type = ARRAY
		\subitem Expression_0.type = ARRAY
		\subitem Expression_1.type = INT $|$ FLOAT $|$ ARRAY
	\item RecordExpression:
		\subitem Type = ARRAY
		\subitem Expression.type = INT $|$ FLOAT
	\item TrackExpression:
		\subitem Type = ARRAY
		\subitem Expression_0.type = ARRAY
		\subitem Expression_1.type = INT $|$ FLOAT
		\subitem Expression_2.type = INT $|$ FLOAT $|$ ARRAY
		\subitem Expression_3.type = INT $|$ FLOAT $|$ ARRAY
	\item MixExpression:
		\subitem Type = ARRAY
		\subitem Expression.type = ARRAY
	\item FuncLitExpression:
		\subitem type = FUNC
		\subitem inputType = UnassignedDeclaration.type
		\subitem returnType = Expression.type
	\item FuncApplicationExpression:
		\subitem type = IdentExpression.returnType
		\subitem Expression.type = IdentExpression.inputType
	\item FuncCompositionExpression:
	\begin{itemize}
		\item Every lambda must have been declared in some enclosing scope
		\item The return type of each lambda must match the input type of the next 
		\item inputType = IdentExpression.inputType
		\item type = FuncApplicationExpression.type
	\end{itemize}
\end{itemize}