\chapter{}

\section{List of Terminal Symbols}
\label{sec:symbols}

\subsubsection{Binary Expressions}

\begin{itemize}
	\item expression := term (comparison term)$^*$
	\item comparison := \texttt{LT} $|$ \texttt{LE} $|$ \texttt{GT} $|$ \texttt{GE} $|$ \texttt{EQUAL} $|$ \texttt{NOTEQUAL}
	\item term := summand (summandOp summand)$^*$
	\item summandOp := \texttt{PLUS} $|$ \texttt{MINUS} $|$ \texttt{OR}
	\item summand := factor (factorOp factor)$^*$
	\item factorOp := \texttt{TIMES} $|$ \texttt{DIV} $|$ \texttt{MOD} $|$ \texttt{AND}
	\item factor := parethesizedExpression $|$ unaryExpression $|$ identExpression
	\item parethesizedExpression := \texttt{LPAREN} expression \texttt{RPAREN}
	\item unaryExpression := (\texttt{KW\_MINUS} $|$ \texttt{KW\_NOT}) expression
	\item identExpression := \texttt{IDENT}
\end{itemize}

\subsubsection{Literal Expressions}

Literal expressions are the simplest constructs in the language, and have the following concrete rules:

\begin{itemize}
	\item factor := intLitExpression $|$ floatLitExpression
	\item factor := boolLitExpression $|$ stringLitExpression
	\item intLitExpression := \texttt{INT\_LIT}
	\item floatLitExpression := \texttt{FLOAT\_LIT}
	\item boolLitExpression := \texttt{KW\_TRUE} $|$ \texttt{KW\_FALSE}
	\item stringLitExpression := \texttt{STRING\_LIT}
\end{itemize}

In the productions above, we note that non-zero integer literals are not allowed to start with a zero. In such a scenario, even though the scanner will create two tokes, one for zero, and another for the rest of the number, since there are no productions in the language that take two integers separated by white space, the parser inevitably will throw a compilation error. The same applies to floating-point decimals, where only one zero can come before the dot. I this particular case, a zero actually \emph{must} precede the \texttt{DOT} token, and such constructs as $x = .5$ are not allowed. Doubles, shorts, or longs do not exist in \emph{Scandal} as of yet, and there is no need to declare float literals the way they are in \emph{Java}, with $1.1f$ for float and $1.1$ for double, say. In fact, that will throw an error. As previously mentioned, string literals are constructed by enclosing text within quotes, and the use of apostrophes will cause a scanning error. Even though quotes are in the language's alphabet, they are never converted into a \il{Token}, as their only possible use is within a string literal. \texttt{DOT}, on the other hand, has uses besides separating the decimal part of a \texttt{FLOAT\_LIT}, namely in composed lambdas. Hence the scanner simply instantiates a token and delegates the inferring of meaning to the parser. Boolean literals are quite self-explanatory, and unlike \emph{C}, numbers are not allowed to replace booleans.

\subsubsection{Array Expressions}

\begin{itemize}
	\item factor := arrayLitExpression $|$ arrayItemExpression
	\item factor := arraySizeExpression $|$ newArrayExpression
	\item arrayLitExpression := \texttt{LBRACKET} expression (\texttt{COMMA} expression)$^*$ \texttt{RBRACKET}
	\item arrayItemExpression := identExpression \texttt{LBRACKET} expression \texttt{RBRACKET}
	\item arraySizeExpression := \texttt{KW\_SIZE} \texttt{LPAREN} expression \texttt{RPAREN}
	\item newArrayExpression := \texttt{KW\_NEW} \texttt{LPAREN} expression \texttt{RPAREN}
\end{itemize}

\subsubsection{Framework Expressions}

\begin{itemize}
	\item factor := piExpression $|$ cosExpression $|$ powExpression
	\item factor := floorExpression $|$ readExpression $|$ recordExpression
	\item piExpression := \texttt{KW\_PI}
	\item cosExpression := \texttt{KW\_COS} \texttt{LPAREN} expression \texttt{RPAREN}
	\item powExpression := \texttt{KW\_POW} \texttt{LPAREN} expression \texttt{RPAREN}
	\item floorExpression := \texttt{KW\_FLOOR} \texttt{LPAREN} expression \texttt{RPAREN}
	\item readExpression := \texttt{KW\_READ} \texttt{LPAREN} expression \texttt{COMMA} expression \texttt{RPAREN}
	\item recordExpression := \texttt{KW\_RECORD} \texttt{LPAREN} expression \texttt{RPAREN}
\end{itemize}

\subsubsection{Lambda Expressions}

\begin{itemize}
	\item lambdaLitExpression := (paramDeclaration)$^*$ expression
	\item lambdaLitBlock := (paramDeclaration)$^*$ returnBlock
	\item returnBLock := (assignmentDec $|$ statement)$^*$ expression


	\item factor := lambdaApp $|$ lambdaComp $|$ lambdaLit $|$ lambdaBlock
	\item lambdaApp := identExpression \texttt{LPAREN} expression (\texttt{COMMA} expression)$^*$ \texttt{RPAREN}
	\item lambdaComp := identExpression (\texttt{DOT} expression)$^*$
	\item lambdaComp := identExpression (\texttt{DOT} expression)$^*$ \texttt{DOT} lambdaApp
	\item lambdaLit := paramDeclaration \texttt{ARROW} (paramDeclaration \texttt{ARROW})$^*$ expression
	\item lambdaBlock := paramDeclaration \texttt{ARROW} (paramDeclaration \texttt{ARROW})$^*$ retBlock
	\item paramDeclaration := type \texttt{IDENT}
	\item retBlock := \texttt{LBRACE} (assignmentDeclaration $|$ statement)$^*$ retExpression \texttt{RBRACE}
	\item retExpression := \texttt{KW\_RETURN} expression
\end{itemize}

\subsection{The Abstract Syntax}

\begin{itemize}
	\item Expression := BinaryExpression $|$ IdentExpression $|$ LiteralExpression
	\item Expression := ArrayExpression $|$ UnaryExpression $|$ FrameworkExpression
	\item Expression := LambdaExpression
	\item BinaryExpression := Expression_0 (termOperator $|$ summandOperator $|$ factorOperator) Expression_1
	\item ReadExpression := Expression_0 Expression_1
	\item LambdaApp := IdentExpression Expression
	\item LambdaComp := IdentExpression^+ LambdaApp
	\item LambdaLit := ParamDeclaration$^+$ Expression
	\item LambdaBlock := ParamDeclaration$^+$ ReturnExpression
	\item ParamDeclaration := Type IDENT
\end{itemize}

\section{Type-Checker Rules}

\begin{itemize}
	\item UnaryExpression:
		\subitem Type = Expression.type
		\subitem Expression.type = INT $|$ FLOAT $|$ BOOL
	\item BinaryExpression:
		\subitem (INT $|$ FLOAT) (MOD $|$ PLUS $|$ MINUS $|$ TIMES $|$ DIV) (FLOAT $|$ INT) ==> FLOAT
		\subitem INT (summandOperator $|$ factorOperator) INT ==> INT
		\subitem (INT $|$ BOOL) (AND $|$ OR) (BOOL $|$ INT) ==> BOOL
		\subitem !(ARRAY $|$ STRING) termOperator !(STRING $|$ ARRAY) ==> BOOL
	\item IdentExpression:
		\subitem Variable must have been declared in some enclosing scope
		\subitem Type = Declaration.type
	\item IntLitExpression:
		\subitem Type = INT
	\item FloatLitExpression:
		\subitem Type = FLOAT
	\item BoolLitExpression:
		\subitem Type = BOOL
	\item StringLitExpression:
		\subitem Type = STRING
	\item ArrayLitExpression:
		\subitem Type = ARRAY
	\item ReadExpression:
		\subitem Type = ARRAY
		\subitem Expression_0.type = STRING
		\subitem Expression_1.type = FORMAT
	\item RecordExpression:
		\subitem Type = ARRAY
		\subitem Expression.type = INT $|$ FLOAT
	\item FuncLitExpression:
		\subitem type = FUNC
		\subitem inputType = UnassignedDeclaration.type
		\subitem returnType = Expression.type
	\item FuncAppExpression:
		\subitem type = IdentExpression.returnType
		\subitem Expression.type = IdentExpression.inputType
	\item FuncCompExpression:
	\begin{itemize}
		\item Every lambda must have been declared in some enclosing scope
		\item The return type of each lambda must match the input type of the next 
		\item inputType = IdentExpression.inputType
		\item type = FuncApplicationExpression.type
	\end{itemize}
\end{itemize}
