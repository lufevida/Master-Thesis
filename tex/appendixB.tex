\chapter{}

\section{List of Terminal Symbols} \label{sec:symbols}

\begin{itemize}
	\item UnaryExpression:
		\subitem Type = Expression.type
		\subitem Expression.type = INT $|$ FLOAT $|$ BOOL
	\item BinaryExpression:
		\subitem (INT $|$ FLOAT) (MOD $|$ PLUS $|$ MINUS $|$ TIMES $|$ DIV) (FLOAT $|$ INT) ==> FLOAT
		\subitem INT (summandOperator $|$ factorOperator) INT ==> INT
		\subitem (INT $|$ BOOL) (AND $|$ OR) (BOOL $|$ INT) ==> BOOL
		\subitem !(ARRAY $|$ STRING) termOperator !(STRING $|$ ARRAY) ==> BOOL
	\item IdentExpression:
		\subitem Variable must have been declared in some enclosing scope
		\subitem Type = Declaration.type
	\item IntLitExpression:
		\subitem Type = INT
	\item FloatLitExpression:
		\subitem Type = FLOAT
	\item BoolLitExpression:
		\subitem Type = BOOL
	\item StringLitExpression:
		\subitem Type = STRING
	\item ArrayLitExpression:
		\subitem Type = ARRAY
	\item ReadExpression:
		\subitem Type = ARRAY
		\subitem Expression_0.type = STRING
		\subitem Expression_1.type = FORMAT
	\item RecordExpression:
		\subitem Type = ARRAY
		\subitem Expression.type = INT $|$ FLOAT
	\item FuncLitExpression:
		\subitem type = FUNC
		\subitem inputType = UnassignedDeclaration.type
		\subitem returnType = Expression.type
	\item FuncAppExpression:
		\subitem type = IdentExpression.returnType
		\subitem Expression.type = IdentExpression.inputType
	\item FuncCompExpression:
	\begin{itemize}
		\item Every lambda must have been declared in some enclosing scope
		\item The return type of each lambda must match the input type of the next 
		\item inputType = IdentExpression.inputType
		\item type = FuncApplicationExpression.type
	\end{itemize}
\end{itemize}
