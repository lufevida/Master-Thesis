\chapter{IMPLEMENTATION OVERVIEW}

In this chapter, we present and discuss the tools and methodology utilized to build \emph{Scandal}. We start discussing how to produce sound with the \emph{Java} sound API, and particularly how it handles real-time audio after a thin layer has been added on top of it. We then give a thorough formal presentation on how the domain-specific language was designed, including the machinery involved in building its compiler.

\section{The Real-Time Audio Engine}

The JRE System Library provides a very convenient package of classes that handle the recording and reproduction of real-time audio, namely the \il{javax.sound.sampled} package. In it, we find two classes, \il{TargetDataLine} and \il{SourceDataLine}, that deal respectively with capturing audio data from the system's resources, and playing back buffers of audio data owned by the application. An instance of \il{SourceDataLine} provides a \il{write} method that takes three arguments: an array of bytes to written to a \il{Mixer} object, an integer offset, and an integer length. In \emph{Scandal}, we do not specify a \il{Mixer} object, hence we make use of one provided by the \il{System}. There are two main aspects of the \il{write} method that need to be addressed. Firstly, it blocks the thread in which it lives until the given array of bytes has been written, from offset to length, to the \il{Mixer} its \il{SourceDataLine} contains; secondly, if nothing is done, it returns as it has no more data to write. In order to have real-time audio, one then needs to be constantly feeding this \il{write} method with audio samples, for as long as one wants continuous sound output, even if these buffers of audio samples contain only zeros, i.e., silence. It immediately follows that one must specify exactly how many samples are sent at a time, naturally with consequences to the system's performance. This parameter is commonly referred in the industry as the \emph{vector size}. The trade-off is measured in terms of latency: a large a vector size helps slower systems perform better, or can allow more complex processing, or even increase polyphony, but increases latency, which is bad for any live application, including the generation of MIDI notes, and the recording of live sound from a microphone. A good, low-compromise vector size is usually set to 512 samples, and normally these sizes will be powers of two. In order to specify the preferred vector size, as well as many other environment settings, \emph{Scandal} refers to a static class named \il{Settings}, which contains a static property \il{Settings.vectorSize}.

The aforementioned two characteristics of the \il{write} method within a \il{SourceDataLine} are managed by \emph{Scandal} by the class \il{AudioFlow}. In order to prevent \il{write} from prematurely returning, an instance of \il{AudioFlow} contains a volatile boolean property named \il{running}, which is set to \il{true} for as long as real-time audio is desired. The fact that \il{write} blocks its thread, however, is managed by any class that contains itself an instance of \il{AudioFlow} as a property. The latter are in \emph{Scandal} the implementors of the \il{RealTimePerformer} interface, which is a contract that contains four abstract methods: \il{startFlow}, \il{stopFlow}, \il{getVector}, and \il{processMasterEffects}. The role of the \il{startFlow} is to merely embed an \il{AudioFlow} within a new \il{Thread} object and start this new thread. This guarantees the thread that manages audio is different than the main \il{Application} thread, hence resolving the thread-blocking issue. Once a new \il{Thread} is started in \emph{Java}, however, one cannot in general interrupt it. In order to stop the audio thread, we set the property \il{running} inside an \il{AudioFlow} to false via the \il{stopFlow} method, which causes the \il{write} method inside the \il{AudioFlow} to return. Hence one cannot resume an audio process in \emph{Scandal} at this point, even though doing so is perfectly possible in \emph{Java}. The reason for that is not that of a design choice, but rather the fact that the domain-specific language is at its infancy, and many important features that go beyond a proof-of-concept are yet to be implemented. The \il{getBuffer} method is called by the \il{AudioFlow} every time it needs to write another vector of audio samples. It is the responsibility then of any \il{RealTimePerformer} to timely compute the next \il{Settings.vectorSize} samples of audio data. Finally, the \il{processMasterEffects} routine is called from within \il{getVector} to further process the buffer of audio samples. This is usually done while the samples are still represented as floats, hence before converting them to raw bytes.

The constructor of an \il{AudioFlow} takes, in addition to a reference to a \il{RealTimePerformer}, a reference to an \il{AudioFormat} object. The latter is part of the \il{javax.sound.sampled} package and is how we ask the \il{AudioSystem} for a \il{SourceDataLine}. Instead of constructing \il{AudioFormat} objects, however, the \il{Settings} class contains static members \il{Settings.mono} and \il{Settings.stereo} that are instances of \il{AudioFormat} defining a mono and stereo format, respectively. In addition to a channel count argument, \il{AudioFormat} instances are constructed by specifying a sampling rate, and a bit depth (word length) for audio samples. Those are, too, static properties in the \il{Settings} class, namely \il{Settings.samplingRate} and \il{Settings.bitDepth}. Listing \ref{alg:play} gives the specifics of maintaining a \il{SourceDataLine} open inside an instance of \il{AudioFlow}. The latter implements, in turn, the \il{Runnable} interface, hence needs to override a \il{run} method. Inside this \il{run} method, we call the private \il{play} subroutine that is given below:

\begin{lstlisting}[language=Java,caption={Writing buffers of audio data inside the \il{play} subroutine.},label={alg:play}]
private void play() throws Exception {
	SourceDataLine sourceDataLine = AudioSystem.getSourceDataLine(format);
	sourceDataLine.open(format, Settings.vectorSize * Settings.bitDepth / 8);
	sourceDataLine.start();
	while (running) {
		ByteBuffer buffer = performer.getVector();
		sourceDataLine.write(buffer.array(), 0, buffer.position());
	}
	sourceDataLine.stop();
	sourceDataLine.close();
}
\end{lstlisting}

Inside the \il{play} subroutine, we acquire a \il{SourceDataLine} object from the \il{AudioSystem} with the specific format that the \il{RealTimePerformer} passed while constructing this \il{AudioFlow}. In order to \il{open} the data line, we need specify a buffer size in bytes, hence we multiply the vector size by the word length in bits, divided by eight, as there are eight bits per byte. We then \il{start} the data line and keep writing to it for as long as the \il{RealTimePerformer} maintains the \il{running} property inside its \il{AudioFlow} set to true. At each call to \il{write}, we ask the performer for a new vector. Filling the vector causes its position to advance until its length, hence the \il{position} method inside the \il{ByteBuffer} class will in fact return the length value we desire. The rest of the \il{play} subroutine simply releases resources before returning, at which point the audio thread is destroyed.

\section{The Structure of the Compiler}

In a broad perspective, the compilation process of \emph{Scandal}'s DSL has the following steps:

\begin{enumerate}
	\item A path to a \emph{.scandal} file is passed as an argument to the constructor of the compiler and a linker subroutine is called, in order to resolve any dependencies;
	\item The code is passed through a scanner, which removes white space and comments while converting strings of characters to tokens. Any illegal symbol will cause the scanner to throw an error, interrupting the compilation process;
	\item The tokens are parsed and converted into an abstract syntax tree, during which many tokens are discarded. If the order of the tokes does not match any of the constructs that \emph{Scandal} understands, the parser throws an error and interrupts the compilation process;
	\item The root of the AST begins the process of \emph{decorating} the tree, in which name references are resolved, types are checked, and variable slot numbers are assigned, whenever applicable. To keep track of names, a LeBlanc-Cook symbol table is kept. If types do not match, or names cannot be referenced, the offending node in the AST throws an error, aborting the compilation;
	\item Again starting from the root of the AST, each node generates its corresponding bytecode, making use of the \il{org.objectweb.asm} library as a facilitator. For any node that is a subroutine, its body is added following its declaration. No errors are thrown in this phase, and the root node returns an array of bytes containing the program's instructions in \emph{Java} bytecode format;
	\item Every \emph{Scandal} program implements the \il{Runnable} interface. After the compiler receives the program's bytecode, it dynamically loads that bytecode as a \emph{Java} class on the current (main) thread, causing the \emph{Scandal} program to be executed.
\end{enumerate}

\subsection{The Linking Process}

The main entry point to the compilation process is given by the \il{Compiler} class, whose constructor requires a path to a \emph{.scandal} file. This class contains a \il{link} routine that is called before each compilation to resolve dependencies, and which is given in Listing \ref{alg:link} below. The \il{Compiler} class has a property named \il{imports}, which is an array of paths to other \emph{.scandal} files upon which the program at hand depends. It also holds a \il{path} property, which was passed to its constructor, and which is used as an argument to \il{link}'s first call. A \emph{Scandal} program may have at its outermost scope \il{import} statements, which take a single string as a parameter, which in turn represents a path to a \emph{.scandal} file in the file system. Any code contained in the file may depend on this imported path's content. Similarly, the imported path's content may depend itself on other imports, and so on, provided there is no circularity, that is, nothing imports something that depends on itself. We may regard then the linking process as a directed graph, in which arrows point toward dependencies. Since we do not allow cycles, this is a directed acyclic graph. It may very well be the case that more than one import depend on a particular file, in which case we certainly do not want to import that code twice. In order to import each dependency exactly once in an order that will satisfy every node of the DAG that points to it, we need to somehow sort the array of imports. It is easy to see that this is no different than the problem of donning garments, in which one must have her socks on before putting her shoes, and where some items may call for no particular order, such as a watch \cite[612]{Cormen2009}. The solution for this problem is to topologically sort the array of imports. Since it is a DAG, however, that is very easily accomplished by a depth-first search of the graph, which is exactly what Listing \ref{alg:link} accomplishes recursively.

\begin{lstlisting}[language=Java,caption={The linking process of a \emph{Scandal} program.},label={alg:link}]
private void link(String inPath) throws Exception {
	if (imports.contains(inPath)) return;
	Program program = getProgram(getCode(inPath));
	for (Node node : program.nodes)
		if (node instanceof ImportStatement)
			link(((ImportStatement) node).expression.firstToken.text);
	imports.add(inPath);
}
\end{lstlisting}

The if-statement in line 2 of the \il{link} routine deals with the base case of the recursion, namely the case in which we have already discovered that vertex. If we are seeing a vertex for the first time, line 3 converts the code into an AST, so we can check for any \il{import} statements therein. That is, in turn, accomplished by the for-loop in line 4, which checks each node in the AST's outermost scope for \il{import} statements. For each one it finds, line 6 recursively calls the \il{link} routine with the path extracted from that \il{import} statement. Since any code upon which we might depend needs to appear \emph{before} our own, the first vertex that is finished needs to go in front of the list, and so on. To be precise, this is a \emph{reverse} topological order. If the chain of imports given by the user contains a cycle, then no topological order exists, and the \emph{Scandal} program will throw a runtime error. This is not ideal, and future versions of \emph{Scandal} will throw a compilation error instead. In order to do so, however, more structure needs to be added to the compiler, so that we may check for backward edges in the linking process, although this feature remains unimplemented.

\subsection{The Scanning Process}

The design of the entire complier takes full advantage of \emph{Java}'s object-oriented paradigm. In order to convert strings of characters from the input file into tokens, we first define a particular \emph{type} of token for each individual construct in the DSL. This is accomplished by the \il{Token} class, which contains a static enumeration \il{Kind}, that in turn defines a type for each string of characters the DSL understands. The constructor of \il{Token} takes a \il{Token.Kind} as input, and each instance of \il{Token} contains, in addition, a \il{text} property, which holds the particular string of characters for that token's kind, as well as other properties that are convenient when throwing errors, namely that token's line number, position within the input array of characters, position within the line, and length. The \il{Token} class also contains methods for converting strings into numbers, as well as convenience methods for determining whether the kind of a particular instance of \il{Token} belongs to a particular \emph{family} of tokens, i.e., whether a token is an arithmetic operator, or whether it is a comparison operator, and so on.

What the \il{Scanner} class accomplishes is the conversion of an array of characters into an array of instances of \il{Token}. The mechanism is conceptually very simple: we scan the input array from left to right and, whenever we see a string of characters that matches one of the DSL's constructs, we instantiate a new \il{Token} and add it to the array of tokens we hold, in order. In the process, we skip any white space found. These can be tab characters, space characters, new lines, hence \emph{Scandal}, unlike \emph{Python} or \emph{Make}, makes no syntactical use of line breaks or indentation. The only role white spaces play in a \emph{Scandal} program is that of improved readability and separation of tokens. \emph{Scandal} also supports two kinds of comments: single-line, which are preceded by two forward slashes, and multi-line, where a slash \emph{immediately} followed by a star character initiates the comment, and a start immediately followed by a slash terminates it. Unlike \emph{Java} or \emph{Swift}, comments are not processed as documentation, and are thus completely discarded. Their only purpose is to document the \emph{.scandal} file in which they are contained. String literals in \emph{Scandal} are declared by enclosing the text between quotes, and single apostrophe are neither allowed, nor in the language's alphabet anywhere. Besides token kinds that bear syntactical relevance, there is an additional \emph{end-of-file} kind that exists for convenience, and is placed at the end of the token array right before the \il{scan} method returns. Checking for illegal characters, or combinations thereof, such as a name that begins with a number, for example, is all the checking the \il{Scanner} class does. All syntactical checking is delegated to the parsing stage of compilation.

\subsection{The Parsing Process}

The main purpose of the parsing stage is to convert the concrete syntax of a \emph{Scandal} program into an abstract syntax tree, where constructs are hierarchically embedded in one another. An instance of the \il{Parser} class is constructed by passing a reference to a \il{Scanner} object. The process is unraveled by invoking the \il{parse} method, which returns an instance of the \il{Program} class. A \il{Program} is a subclass of \il{Node}, an abstract class that provides basic structure for every node in the AST. In particular, \il{Program} is the node that lies at the root of the AST. For each construct specified by the concrete syntax of \emph{Scandal}, there is a corresponding construct specified by its abstract syntax. More often than not, the abstract construct will be simpler, sometimes with many tokens removed. The job of the parser is to facilitate the process of inferring meaning from a given program, and it does so by going, from left to right, through the array of tokens passed by the scanner and, whenever it sees a sequence of tokens that matches one of the constructs in the concrete syntax, it consumes those tokens and creates a subclass of \il{Node} that corresponds to the construct at hand. It follows, for every acceptable construct in the DSL, there is a subclass of \il{Node} that defines it. Some nodes are nested hierarchically in others, and ultimately all nodes are nested in an instance of \il{Program}, hence why the parsing stage ultimately constructs a tree.

Structuring a program hierarchically is essential for inferring the meaning of complex expressions that have some sort of precedence relation among its sub-expressions. That is the case of arithmetic operations, in which, say, multiplication has precedence over addition, and exponentiation has precedence over multiplication. As an example, \emph{Supercollider} evaluates $3 + 3 * 3$ to $18$, since it parses the expression from left to right without regard for the precedence relations among arithmetic operators. This is counterintuitive, and does not correspond to how mathematical expressions are evaluated in general. We would like, instead, the expression $3 + 3 * 3$ to evaluate to $12$, in which case we cannot take it from left to right. Rather, we must first evaluate $e_2 = 3 * 3$, \emph{then} evaluate $e_1 = 3 + e_2$. It is easy to see that, no matter how complex the expression might be, we can always represent it as a \emph{binary} tree by taking the leftmost, highest-precedence operator and splitting the expression in half at that point. We then look at each sub-expression and do the same, until we reach a leaf. Note that the AST is not, in general, a binary tree. If two operators have the same precedence, we associate from left to right, that is, $1 - 2 + 3 = (1 - 2) + 3 = 2$, which also corresponds to how mathematical expressions associate. Complex expressions are dealt in \emph{Scandal} by the \il{BinaryExpression} class, and the fact that instances of \il{BinaryExpression} may contain other instances of \il{BinaryExpression} simply means we must construct them recursively. We shall discuss in detail each syntactical construct of \emph{Scandal} in the sections that follow, along with their concrete and abstract syntax definitions, and parsing routines.

\subsection{Decorating the AST}

The idea of representing a program as a tree has many advantages, chief among them being the fact we can traverse the tree to infer its meaning. This is often non-trivial, and is necessary as many constructs are name-references to other constructs, and require that we look back to how they were originally declared if we are to make sense of them. In \emph{Scandal}, every subclass of \il{Node} overrides the abstract method \il{decorate}, which in turn takes an instance of \il{SymbolTable} as an argument. The latter is a class that implements a LeBlanc-Cook symbol table \cite{Cook1983}. Several nodes in the DSL define new naming scopes, \il{Program} being the node that holds the zeroth scope. These nodes are namely those that have \il{Block}, or its subclass \il{LambdaBlock} as members. \il{IfStatement} and \il{WhileStatement} both have \il{Block} as a child node, whereas \il{LambdaLitBlock} points to a \il{LambdaBlock}, who differs from \il{Block} in that it has a return statement. \il{LambdaBlock} only exist in the context of a lambda literal expression, however instances of \il{Block}, inside if or while-statements or on their own, may exits arbitrarily, always defining new naming scopes. Every time we enter a new scope in \emph{Scandal}, we have access to variables that were declared in outer scopes, but the converse is not true. Also, every time we enter a new scope, we have the opportunity of re-declaring variables' names without the risk of clashing with names already declared in outer scopes. For each scope, we hold a hash table whose keys are the variables' names, and whose values are subclasses of the abstract type \il{Declaration}. In order to \emph{remember} as we enter new scopes, and \emph{forget} as we leave them, an instance of \il{SymbolTable} holds a \il{Stack} of name-declaration hash tables, since stacks are exactly the kind of data structure that gives us this last-in, first-out behavior. In order to trigger the whole process of decorating the AST, the \il{Compiler} class instantiates a \il{SymbolTable}, and passes that as an argument to the instance of \il{Program} that was returned by the parser. Listing~\ref{alg:compile} shows how this is done in the \il{compile} method inside \il{Program}. Since every node overrides the \il{decorate} method, this instance of \il{SymbolTable} is passed down along the entire tree. Nodes that introduce new naming scopes have the responsibility of pushing a new hash table onto the stack, then popping it before returning from the \il{decorate} method.

In addition to resolving names, the decoration process is crucial for type-checking expressions and statements in the DSL. Even though the \emph{Java} bytecode instructions are explicitly typed, languages that compile to bytecode do not need to be. That is the case of \emph{Scala} and \emph{Groovy}, in which types can be inferred, or declared explicitly. Furthermore, there is a degree of latitude to which types can actually \emph{change} in the bytecode implementation. The JVM only cares that, once a variable is stored in a certain slot number as, say, a float, that is, using the instruction \il{FSTORE}, that it be retrieved too as a float, that is, using the instruction \il{FLOAD}. It is perfectly possible to use the same slot number to, say, \il{ISTORE} an integer value. The only consistency the JVM requires is that, for as long as that slot holds an integer, the value can only be retrieved by an \il{ILOAD} instruction. This requirement naturally extends to method signatures, which are also explicitly typed in the JVM. Hence, like \emph{JavaScript}, one can theoretically change the type of a variable attached to a name after it has been declared; unlike \emph{JavaScript}, however, types have to be assigned to arguments when declaring a method, and that method signature is immutable. It is still possible to overload a method to accept multiple signatures, but overloaded names are still \emph{different} methods, with altogether different bodies. The same applies to non-primitive types, that is, types that are instances of a class in the JVM. To store or retrieve non-primitive types, we use the \il{ASTORE} and \il{ALOAD} JVM instructions, respectively. Hence it is also theoretically possible to overwrite non-primitive types. However, method signatures that take non-primitives require a fully-qualified class name, hence are immutable as above. A fully-qualified name is the name of the class, preceded by the names of the packages in which it is contained, separated by forward slashes. For \il{Compiler}, for example, we have \il{language/compiler/Compiler}.

\begin{lstlisting}[language=Java,caption={Triggering the compilation process of a \emph{Scandal} program.},label={alg:compile}]
public void compile() throws Exception {
	imports.clear();
	code = "";
	link(path);
	for (String p : imports) code += getCode(p);
	symtab = new SymbolTable(className);
	program = getProgram(code);
	program.decorate(symtab);
	program.generate(null, symtab);
}
\end{lstlisting}

\emph{Scandal} is, by design choice, statically typed. There are many reasons for that. The main reason is that the only kind of method it supports is that of a lambda expression, even though \emph{Scandal} is not a pure functional language. These lambda expressions define themselves their own parametrized sub-types, hence a lot of what the language \emph{is} hinges on type safety. It is also a design choice to make \emph{Scandal} accessible as an entry-level language, that is, directed toward an audience interested in learning audio signal processing in more depth, without the implementation hiding inherent to the unit-generator concept. Having types explicitly defined can help inexperienced programmers better debug their code, as well as help them understand the underlying implementation of the language. Type inference is, in essence, another way of hiding implementation, which has advantages, but also drawbacks. It is notoriously difficult to report errors and debug large projects in an IDE with languages that are dynamically typed. That is certainly the case with \emph{JavaScript}, of which \emph{TypeScript} is a typed superset aimed exactly at facilitating development within an IDE. \emph{Scandal} is fully integrate into its IDE, where reporting compilation errors to the programmer is a lot more informative, hence educational, than throwing runtime errors and aborting execution. For all these reasons, type-checking is one of the main jobs the decoration process accomplished. It can become rather involved, especially when it comes to composing partial applications of lambda expressions. We shall describe the intricacies of type checking alongside each of the DSL's constructs in the sections that follow.

\subsection{Generating Bytecode}

Similarly to the decoration process, bytecode generation is triggered from the root of the AST, that is, an instance of \il{Program} received from the parser, and which has been already decorated, and passed down to every node of the tree by a common abstract method each subclass of \il{Node} overrides. In this case, this common method is called \il{generate}, and it takes two arguments. The first is an instance of \il{org.objectweb.asm.MethodVisitor}, and the second is the the decorated instance of \il{SymbolTable}. \il{MethodVisitor} is part of the ASM library, which is a convenient set of tools aimed at facilitating the generation of \emph{Java} bytecode. As the name suggests, it visits a method within the bytecode class and adds statements to it. As can be seen in line 9 of Listing~\ref{alg:compile}, a null pointer is passed to the very first call to \il{generate}, since at that point we have not created any methods in the bytecode class yet. Every \emph{Scandal} program compiles to a \emph{Java} class, which in turn implements the \il{Runnable} interface. Inside the class, there are three methods: \il{init}, where we create the method bodies of lambda literal expressions, which are always fields in the \emph{Java} class; \il{run}, which is a required override of the \il{Runnable} interface, and where we create all \emph{Scandal} local variables and statements; and \il{main}, where we instantiate the class and call \il{run}. Inside \il{Program}, the \il{generate} method creates three instances of \il{MethodVisitor}, one for each aforementioned method.

If and only if a child node is an instance of \il{LambdaLitDeclaration}, a \il{Node} used to declare a name and assign to it a lambda literal expression, this child node is passed an instance of \il{MethodVisitor} that lives inside the \il{init} method. The immediate implication of this design choice is that lambda literal expressions are always global variables in a \emph{Scandal} program, thus accessible everywhere. However, they must be declared at the outermost scope of the program, and will throw a compilation error if declared elsewhere. A similar design pattern applies to nodes that are instances of \il{FieldDeclaration}, a \il{Node} used to declare field variables in the \emph{Java} class, which in turn correspond to global variables in the \emph{Scandal} program. For both \il{LambdaLitDeclaration} and \il{FieldDeclaration} nodes, we need to add field declarations in the \emph{Java} class, which is accomplished by instantiating, for each of these nodes, a \il{org.objectweb.asm.FieldVisitor}. This is only ever done inside \il{Program} hence, as a consequence, global variables in a \emph{Scandal} program must always be declared at the outermost scope. Similarly to instances of \il{LambdaLitDeclaration}, instances of \il{FieldDeclaration} in inner scopes throw a compilation error. Every descendant of the root node that is \emph{not} an instance of \il{LambdaLitDeclaration} receives as a parameter to its \il{generate} method an instance of \il{MethodVisitor} that lives inside the \il{run} method of the \emph{Java} class. This includes instances of \il{FieldDeclaration}, which are only declared by a \il{FieldVisitor}, and whose assignment is done inside the \il{run} method, along with all other declarations and statements.

Unlike instances of \il{FieldDeclaration}, instances of \il{LambdaLitDeclaration} are marked as \emph{final} in the \emph{Java} class, hence cannot be reassigned. The reason is simple: once reassigning a variable that points to a method body, the latter may become inaccessible. In \emph{Scandal}, one can create references to lambdas inside the \il{run} method, which are not instances of \il{LambdaLitDeclaration}, that is, which do not specify a method body. These references are rather instances of the superclass \il{AssignmentDeclaration}, and can be freely reassigned, even to lambdas that have different parameters, i.e., method signatures, that that of the original assignment. Reassigning references to lambdas come allow for great code re-usability. There is a third subclass of \il{Node} which can only be used at the outermost scope, namely \il{ImportStatement}. The reason is, besides clarity and organization of \emph{Scandal} code, because the \il{link} routine inside \il{Program} only looks for import statements within the outermost scope of a program's AST. In all three such nodes, checking whether that particular instance lives in the outermost scope is a simple matter of asking the passed instance of \il{SymbolTable} whether the current scope number is zero.

\subsection{Running a \emph{Scandal} Program}

Every \il{Program} node holds an array of bytes corresponding to a binary representation of the compiled \emph{Scandal} program. This array is created right before the \il{generate} method returns. The \il{Compliler} class naturally holds a reference to an instance of \il{Program}, and utilizes the latter's \il{bytecode} property to dynamically instantiate the \emph{Scandal} program as a \emph{Java} class, that is, from an array of bytes stored in memory, rather than from a \emph{.class} in the file system. Within the IDE, a path to a \emph{Scandal} program is used to instantiate a \il{Compiler}. After calling the \il{compile} method, the resulting bytecode is used to define a subclass of \il{java.lang.ClassLoader}, namely \il{DynamicClassLoader}, which is capable of dynamically instantiating a byte array as a \emph{Java} class, as opposed to the instance returned by the static method \il{ClassLoader.getSystemClassLoader()}, which can only load classes from the file system. Once defined, we construct and instantiate the program, finally casting the result to \il{Runnable}, as illustrated in Listing \ref{alg:instance}. The \il{getInstance} method is called from the IDE by the tab that currently holds the pogram's text editor, which is an instance of \il{ScandalTab}. After retrieving the instance of \il{Runnable}, the \il{ScandalTab} simply puts is on a new \il{Thread}. Starting the thread then causes the \emph{Scandal} program to execute.

\begin{lstlisting}[language=Java,caption={Obtaining an instance of a \emph{Scandal} program.},label={alg:instance}]
public Runnable getInstance() throws Exception {
	ClassLoader context = ClassLoader.getSystemClassLoader();
	DynamicClassLoader loader = new DynamicClassLoader(context);
	return (Runnable) loader
			.define(className, program.bytecode)
			.getConstructor()
			.newInstance();
}
\end{lstlisting}